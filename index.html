<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The 10th Realm - Arena Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #connection-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #4a4a6a;
            border-radius: 15px;
            padding: 30px;
            pointer-events: auto;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #connection-panel.hidden {
            display: none;
        }

        #connection-panel h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            background: #2a2a4a;
            color: #fff;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            border-color: #6c63ff;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6c63ff, #4a4aff);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 99, 255, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #4a4a6a;
        }

        .divider {
            text-align: center;
            color: #666;
            margin: 20px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #4a4a6a;
        }

        .divider::before {
            left: 0;
        }

        .divider::after {
            right: 0;
        }

        #your-id {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }

        #your-id label {
            color: #888;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }

        #your-id span {
            color: #6c63ff;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }

        #status.connecting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        #status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        #status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
        }

        #hud h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }

        .player-list {
            list-style: none;
        }

        .player-list li {
            padding: 5px 10px;
            background: rgba(108, 99, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .player-list li.you {
            background: rgba(76, 175, 80, 0.2);
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }

        #controls-help span {
            display: block;
            margin-bottom: 3px;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            pointer-events: none;
        }

        #disconnect-btn {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 8px 16px;
            background: rgba(244, 67, 54, 0.8);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 12px;
        }

        #disconnect-btn:hover {
            background: rgba(244, 67, 54, 1);
        }

        #disconnect-btn.hidden {
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff4444;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #weapon-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #4a4a6a;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
        }

        #weapon-indicator .weapon-name {
            font-size: 18px;
            font-weight: bold;
            color: #6c63ff;
        }

        #weapon-indicator.hidden {
            display: none;
        }

        .copy-btn {
            background: #4a4a6a;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        .copy-btn:hover {
            background: #6c63ff;
        }

        #version-info {
            text-align: center;
            color: #666;
            font-size: 11px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a5a;
        }

        #update-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
            transition: all 0.3s;
        }

        #update-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        #update-btn:disabled {
            background: #3a3a5a;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #update-btn.has-update {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); }
        }

        #update-status {
            font-size: 11px;
            margin-top: 5px;
            color: #888;
        }

        #update-status.update-available {
            color: #ff6b6b;
            font-weight: bold;
        }

        #update-status.up-to-date {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="connection-panel">
                <h2>The 10th Realm</h2>

                <div id="your-id">
                    <label>YOUR PEER ID</label>
                    <span id="peer-id">Connecting...</span>
                    <button class="copy-btn" onclick="copyPeerId()">Copy</button>
                </div>

                <div class="input-group">
                    <label>Enter Friend's Peer ID to Connect</label>
                    <input type="text" id="connect-id" placeholder="Enter peer ID...">
                </div>

                <button id="connect-btn" class="btn btn-primary" onclick="connectToPeer()" disabled>Connect to Friend</button>

                <div class="divider">or</div>

                <button id="solo-btn" class="btn btn-secondary" onclick="startSoloGame()" disabled>Play Solo (Wait for connections)</button>

                <div id="status"></div>

                <div id="version-info">
                    <span>Version <span id="current-version"></span></span>
                    <br>
                    <button id="update-btn" onclick="checkForUpdates()">Check for Updates</button>
                    <div id="update-status"></div>
                </div>
            </div>

            <div id="hud" class="hidden">
                <h3>PLAYERS ONLINE</h3>
                <ul class="player-list" id="player-list"></ul>
            </div>

            <div id="controls-help" class="hidden">
                <span><b>WASD</b> - Move</span>
                <span><b>SHIFT</b> - Sprint</span>
                <span><b>SPACE</b> - Jump (Double Jump!)</span>
                <span><b>Mouse</b> - Look around</span>
                <span><b>Left Click</b> - Attack</span>
                <span><b>Q</b> - Switch Weapon (Gun/Sword)</span>
            </div>

            <canvas id="minimap" class="hidden"></canvas>
            <button id="disconnect-btn" class="hidden" onclick="disconnect()">Disconnect</button>

            <div id="crosshair" class="hidden">
                <div class="dot"></div>
            </div>

            <div id="weapon-indicator" class="hidden">
                <div>Current Weapon</div>
                <div class="weapon-name" id="current-weapon-name">Gun</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // Game Version & Update Config
        const GAME_VERSION = "1.0.0";
        const GITHUB_USER = "mslanden";
        const GITHUB_REPO = "game";
        const VERSION_URL = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/main/version.json`;
        const GAME_URL = `https://${GITHUB_USER}.github.io/${GITHUB_REPO}/`;

        // Game State
        const gameState = {
            players: new Map(),
            localPlayer: null,
            peer: null,
            connections: [],
            isHost: false,
            gameStarted: false
        };

        // Three.js variables
        let scene, camera, renderer, clock;
        let ground, obstacles = [];

        // Player class
        class Player {
            constructor(id, isLocal = false, color = null) {
                this.id = id;
                this.isLocal = isLocal;
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3(
                    Math.random() * 20 - 10,
                    1,
                    Math.random() * 20 - 10
                );
                this.rotation = { x: 0, y: 0 };
                this.isGrounded = true;
                this.isSprinting = false;
                this.jumpCount = 0;
                this.maxJumps = 2; // Double jump enabled
                this.currentWeapon = 'gun'; // 'gun' or 'sword'
                this.isAttacking = false;
                this.attackCooldown = 0;

                // Create player mesh (body)
                const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: color || (isLocal ? 0x4caf50 : this.getRandomColor()),
                    roughness: 0.5,
                    metalness: 0.3
                });
                this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Create head
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffdbac,
                    roughness: 0.6
                });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.9;
                this.head.castShadow = true;
                this.mesh.add(this.head);

                // Create eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 0.05, 0.25);
                this.head.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 0.05, 0.25);
                this.head.add(rightEye);

                // Create weapons
                this.createWeapons();

                // Name tag
                this.nameTag = this.createNameTag(id.substring(0, 8));
                this.nameTag.position.y = 1.8;
                this.mesh.add(this.nameTag);

                this.mesh.position.copy(this.position);

                this.color = bodyMaterial.color.getHex();
            }

            getRandomColor() {
                const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xff9ff3, 0x54a0ff];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createNameTag(name) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.roundRect(0, 0, 256, 64, 10);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 0.5, 1);

                return sprite;
            }

            createWeapons() {
                // Gun weapon
                const gunGroup = new THREE.Group();

                // Gun body (main barrel)
                const gunBody = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.12, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.3 })
                );
                gunGroup.add(gunBody);

                // Gun handle
                const gunHandle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.2, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 })
                );
                gunHandle.position.set(0, -0.12, 0.1);
                gunHandle.rotation.x = 0.3;
                gunGroup.add(gunHandle);

                // Gun barrel tip (muzzle)
                const muzzle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.04, 0.08, 8),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.95, roughness: 0.2 })
                );
                muzzle.rotation.x = Math.PI / 2;
                muzzle.position.set(0, 0, -0.28);
                gunGroup.add(muzzle);

                // Gun sight
                const sight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.04, 0.02),
                    new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0xff0000, emissiveIntensity: 0.5 })
                );
                sight.position.set(0, 0.08, 0.05);
                gunGroup.add(sight);

                gunGroup.position.set(0.4, 0.2, -0.3);
                gunGroup.rotation.y = -0.1;
                this.gun = gunGroup;
                this.mesh.add(this.gun);

                // Sword weapon
                const swordGroup = new THREE.Group();

                // Sword blade
                const bladeGeometry = new THREE.BoxGeometry(0.06, 0.04, 1.0);
                const bladeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc0c0c0,
                    metalness: 0.95,
                    roughness: 0.1,
                    emissive: 0x3366ff,
                    emissiveIntensity: 0.1
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.z = -0.5;
                swordGroup.add(blade);

                // Blade edge glow
                const edgeGlow = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.06, 0.95),
                    new THREE.MeshStandardMaterial({
                        color: 0x66aaff,
                        emissive: 0x4488ff,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                edgeGlow.position.z = -0.5;
                swordGroup.add(edgeGlow);

                // Sword handle
                const handleGeom = new THREE.CylinderGeometry(0.03, 0.035, 0.25, 8);
                const handleMat = new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 });
                const handle = new THREE.Mesh(handleGeom, handleMat);
                handle.rotation.x = Math.PI / 2;
                handle.position.z = 0.12;
                swordGroup.add(handle);

                // Sword guard (crossguard)
                const guard = new THREE.Mesh(
                    new THREE.BoxGeometry(0.25, 0.04, 0.06),
                    new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.3 })
                );
                guard.position.z = 0;
                swordGroup.add(guard);

                // Pommel
                const pommel = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.3 })
                );
                pommel.position.z = 0.25;
                swordGroup.add(pommel);

                swordGroup.position.set(0.4, 0.2, -0.3);
                swordGroup.rotation.x = -0.2;
                this.sword = swordGroup;
                this.sword.visible = false;
                this.mesh.add(this.sword);

                // Muzzle flash (for gun)
                const flashGeom = new THREE.SphereGeometry(0.1, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0
                });
                this.muzzleFlash = new THREE.Mesh(flashGeom, flashMat);
                this.muzzleFlash.position.set(0, 0, -0.35);
                this.gun.add(this.muzzleFlash);
            }

            switchWeapon(weapon) {
                this.currentWeapon = weapon;
                this.gun.visible = weapon === 'gun';
                this.sword.visible = weapon === 'sword';
            }

            attack(scene, camera) {
                if (this.attackCooldown > 0 || !this.isLocal) return;

                this.isAttacking = true;

                if (this.currentWeapon === 'gun') {
                    this.attackCooldown = 0.25; // Fire rate
                    this.shootGun(scene, camera);
                } else {
                    this.attackCooldown = 0.5; // Swing rate
                    this.swingSword();
                }
            }

            shootGun(scene, camera) {
                // Muzzle flash
                this.muzzleFlash.material.opacity = 1;
                setTimeout(() => {
                    if (this.muzzleFlash) this.muzzleFlash.material.opacity = 0;
                }, 50);

                // Create bullet tracer
                const bulletGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
                const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const bullet = new THREE.Mesh(bulletGeom, bulletMat);

                // Get shooting direction from camera
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                // Start position at gun muzzle
                const startPos = this.mesh.position.clone();
                startPos.y += 0.7;
                startPos.add(direction.clone().multiplyScalar(0.8));

                bullet.position.copy(startPos);
                bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                scene.add(bullet);

                // Animate bullet
                const speed = 80;
                const maxDistance = 100;
                let traveled = 0;

                const animateBullet = () => {
                    if (traveled >= maxDistance) {
                        scene.remove(bullet);
                        return;
                    }
                    bullet.position.add(direction.clone().multiplyScalar(speed * 0.016));
                    traveled += speed * 0.016;
                    requestAnimationFrame(animateBullet);
                };
                animateBullet();
            }

            swingSword() {
                // Sword swing animation
                const startRotation = this.sword.rotation.x;
                const swingAmount = -Math.PI / 2;
                let progress = 0;

                const animateSwing = () => {
                    progress += 0.15;
                    if (progress <= 1) {
                        const swing = Math.sin(progress * Math.PI) * swingAmount;
                        this.sword.rotation.x = startRotation + swing;
                        requestAnimationFrame(animateSwing);
                    } else {
                        this.sword.rotation.x = startRotation;
                        this.isAttacking = false;
                    }
                };
                animateSwing();
            }

            update(delta, keys, cameraYaw) {
                if (!this.isLocal) return;

                const moveSpeed = this.isSprinting ? 12 : 6;
                const jumpForce = 8;
                const gravity = 20;

                // Movement direction based on camera
                const direction = new THREE.Vector3();

                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

                    this.velocity.x = direction.x * moveSpeed;
                    this.velocity.z = direction.z * moveSpeed;

                    // Rotate player to face movement direction
                    this.rotation.y = Math.atan2(direction.x, direction.z);
                } else {
                    this.velocity.x *= 0.9;
                    this.velocity.z *= 0.9;
                }

                // Sprint
                this.isSprinting = keys.sprint && direction.length() > 0;

                // Jump (with double jump)
                if (keys.jump && !keys.jumpHeld && this.jumpCount < this.maxJumps) {
                    this.velocity.y = jumpForce;
                    this.jumpCount++;
                    this.isGrounded = false;
                    keys.jumpHeld = true;
                }
                if (!keys.jump) {
                    keys.jumpHeld = false;
                }

                // Apply gravity
                if (!this.isGrounded) {
                    this.velocity.y -= gravity * delta;
                }

                // Update position
                this.position.x += this.velocity.x * delta;
                this.position.y += this.velocity.y * delta;
                this.position.z += this.velocity.z * delta;

                // Ground collision
                if (this.position.y <= 1) {
                    this.position.y = 1;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    this.jumpCount = 0; // Reset double jump
                }

                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }

                // World boundaries
                const boundary = 45;
                this.position.x = Math.max(-boundary, Math.min(boundary, this.position.x));
                this.position.z = Math.max(-boundary, Math.min(boundary, this.position.z));

                // Collision with obstacles
                this.checkCollisions();

                // Update mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;
            }

            checkCollisions() {
                for (const obstacle of obstacles) {
                    const box = new THREE.Box3().setFromObject(obstacle);
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        this.position,
                        new THREE.Vector3(0.8, 2, 0.8)
                    );

                    if (box.intersectsBox(playerBox)) {
                        // Simple push-back collision
                        const obstacleCenter = new THREE.Vector3();
                        box.getCenter(obstacleCenter);

                        const pushDir = this.position.clone().sub(obstacleCenter);
                        pushDir.y = 0;
                        pushDir.normalize();

                        this.position.add(pushDir.multiplyScalar(0.1));
                    }
                }
            }

            updateFromNetwork(data) {
                if (this.isLocal) return;

                this.position.lerp(new THREE.Vector3(data.x, data.y, data.z), 0.3);
                this.rotation.y = data.ry;

                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;
            }

            getNetworkData() {
                return {
                    id: this.id,
                    x: this.position.x,
                    y: this.position.y,
                    z: this.position.z,
                    ry: this.rotation.y,
                    color: this.color
                };
            }
        }

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0x6060ff, 0x404040, 0.4);
            scene.add(hemiLight);

            // Ground with better visuals
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 100, 100);

            // Add some height variation for visual interest
            const positions = groundGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] = Math.sin(positions[i] * 0.1) * Math.cos(positions[i + 1] * 0.1) * 0.3;
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a3a,
                roughness: 0.9,
                metalness: 0.1
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Glowing grid lines
            const gridHelper = new THREE.GridHelper(100, 50, 0x6c63ff, 0x2a2a4a);
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Add a subtle glow plane under the grid
            const glowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshBasicMaterial({
                    color: 0x4a4aff,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                })
            );
            glowPlane.rotation.x = -Math.PI / 2;
            glowPlane.position.y = 0.01;
            scene.add(glowPlane);

            // Create obstacles
            createObstacles();

            // Create boundary walls
            createBoundaryWalls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Animated objects for cool effects
        let floatingCrystals = [];
        let glowingOrbs = [];

        function createObstacles() {
            const obstaclePositions = [
                { x: 10, z: 10, w: 4, h: 3, d: 4, type: 'pillar' },
                { x: -15, z: 5, w: 3, h: 5, d: 3, type: 'crystal' },
                { x: 5, z: -20, w: 6, h: 2, d: 6, type: 'platform' },
                { x: -10, z: -15, w: 2, h: 4, d: 8, type: 'wall' },
                { x: 20, z: -10, w: 5, h: 6, d: 2, type: 'pillar' },
                { x: -25, z: 20, w: 4, h: 3, d: 4, type: 'crystal' },
                { x: 30, z: 25, w: 3, h: 4, d: 3, type: 'pillar' },
                { x: -5, z: 30, w: 8, h: 2, d: 2, type: 'platform' },
                { x: 15, z: -30, w: 2, h: 7, d: 2, type: 'tower' },
                { x: -30, z: -25, w: 5, h: 3, d: 5, type: 'platform' },
                { x: 0, z: 0, w: 2, h: 8, d: 2, type: 'tower' },
                { x: 25, z: 15, w: 3, h: 2, d: 6, type: 'wall' }
            ];

            const colors = [0x6c63ff, 0x4ecdc4, 0xff6b6b, 0x45b7d1, 0xf9ca24];

            obstaclePositions.forEach((pos, i) => {
                const color = colors[i % colors.length];
                let obstacle;

                if (pos.type === 'crystal') {
                    // Cool floating crystal
                    const crystalGroup = new THREE.Group();

                    const crystalGeom = new THREE.OctahedronGeometry(pos.w * 0.5, 0);
                    const crystalMat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.1,
                        metalness: 0.8,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.9
                    });
                    const crystal = new THREE.Mesh(crystalGeom, crystalMat);
                    crystal.scale.y = 2;
                    crystalGroup.add(crystal);

                    // Inner glow
                    const glowGeom = new THREE.OctahedronGeometry(pos.w * 0.3, 0);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    const innerGlow = new THREE.Mesh(glowGeom, glowMat);
                    innerGlow.scale.y = 2;
                    crystalGroup.add(innerGlow);

                    crystalGroup.position.set(pos.x, pos.h + 1, pos.z);
                    crystalGroup.userData.floatOffset = Math.random() * Math.PI * 2;
                    crystalGroup.userData.baseY = pos.h + 1;
                    scene.add(crystalGroup);
                    floatingCrystals.push(crystalGroup);

                    // Base platform for crystal
                    const baseGeom = new THREE.CylinderGeometry(pos.w * 0.6, pos.w * 0.8, 0.5, 6);
                    const baseMat = new THREE.MeshStandardMaterial({
                        color: 0x333355,
                        roughness: 0.7,
                        metalness: 0.5
                    });
                    obstacle = new THREE.Mesh(baseGeom, baseMat);
                    obstacle.position.set(pos.x, 0.25, pos.z);
                } else if (pos.type === 'tower') {
                    // Cool tower with rings
                    obstacle = new THREE.Group();

                    const towerGeom = new THREE.CylinderGeometry(pos.w * 0.4, pos.w * 0.5, pos.h, 8);
                    const towerMat = new THREE.MeshStandardMaterial({
                        color: 0x2a2a4a,
                        roughness: 0.4,
                        metalness: 0.6
                    });
                    const tower = new THREE.Mesh(towerGeom, towerMat);
                    tower.position.y = pos.h / 2;
                    tower.castShadow = true;
                    tower.receiveShadow = true;
                    obstacle.add(tower);

                    // Glowing rings
                    for (let r = 0; r < 3; r++) {
                        const ringGeom = new THREE.TorusGeometry(pos.w * 0.6, 0.1, 8, 16);
                        const ringMat = new THREE.MeshStandardMaterial({
                            color: color,
                            emissive: color,
                            emissiveIntensity: 0.5,
                            roughness: 0.3,
                            metalness: 0.7
                        });
                        const ring = new THREE.Mesh(ringGeom, ringMat);
                        ring.rotation.x = Math.PI / 2;
                        ring.position.y = pos.h * 0.25 + (r * pos.h * 0.3);
                        ring.userData.rotationSpeed = 0.01 + Math.random() * 0.02;
                        obstacle.add(ring);
                        glowingOrbs.push(ring);
                    }

                    obstacle.position.set(pos.x, 0, pos.z);
                } else if (pos.type === 'platform') {
                    // Floating platform with glow edges
                    const platformGroup = new THREE.Group();

                    const platGeom = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                    const platMat = new THREE.MeshStandardMaterial({
                        color: 0x3a3a5a,
                        roughness: 0.5,
                        metalness: 0.4
                    });
                    const platform = new THREE.Mesh(platGeom, platMat);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    platformGroup.add(platform);

                    // Edge glow
                    const edgeGeom = new THREE.BoxGeometry(pos.w + 0.1, 0.1, pos.d + 0.1);
                    const edgeMat = new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    });
                    const topEdge = new THREE.Mesh(edgeGeom, edgeMat);
                    topEdge.position.y = pos.h / 2;
                    platformGroup.add(topEdge);

                    const bottomEdge = new THREE.Mesh(edgeGeom, edgeMat);
                    bottomEdge.position.y = -pos.h / 2;
                    platformGroup.add(bottomEdge);

                    platformGroup.position.set(pos.x, pos.h / 2, pos.z);
                    obstacle = platformGroup;
                } else {
                    // Standard pillar/wall with better materials
                    const geometry = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.4,
                        metalness: 0.5,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    obstacle = new THREE.Mesh(geometry, material);
                    obstacle.position.set(pos.x, pos.h / 2, pos.z);
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                }

                if (obstacle.isMesh) {
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                }
                scene.add(obstacle);
                obstacles.push(obstacle);
            });

            // Add some ambient particles/dust
            createParticles();
        }

        function createParticles() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 20;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x6c63ff,
                size: 0.15,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData.positions = positions;
            scene.add(particles);
            glowingOrbs.push(particles);
        }

        function animateEnvironment(time) {
            // Animate floating crystals
            floatingCrystals.forEach(crystal => {
                crystal.position.y = crystal.userData.baseY + Math.sin(time * 2 + crystal.userData.floatOffset) * 0.5;
                crystal.rotation.y += 0.01;
            });

            // Animate glowing rings
            glowingOrbs.forEach(obj => {
                if (obj.userData.rotationSpeed) {
                    obj.rotation.z += obj.userData.rotationSpeed;
                }
                if (obj.isPoints && obj.userData.positions) {
                    // Animate particles
                    const positions = obj.userData.positions;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += 0.01;
                        if (positions[i + 1] > 20) positions[i + 1] = 0;
                    }
                    obj.geometry.attributes.position.needsUpdate = true;
                }
            });
        }

        function createBoundaryWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a6a,
                roughness: 0.9,
                metalness: 0.1,
                transparent: true,
                opacity: 0.3
            });

            const wallHeight = 10;
            const wallThickness = 1;
            const arenaSize = 50;

            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -arenaSize);
            scene.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, arenaSize);
            scene.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            eastWall.position.set(arenaSize, wallHeight / 2, 0);
            scene.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            westWall.position.set(-arenaSize, wallHeight / 2, 0);
            scene.add(westWall);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Input handling
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            jumpHeld: false,
            sprint: false,
            attack: false,
            switchWeapon: false
        };

        let cameraYaw = 0;
        let cameraPitch = 0;
        let isPointerLocked = false;

        function initInput() {
            document.addEventListener('keydown', (e) => {
                if (!gameState.gameStarted) return;

                switch (e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space': keys.jump = true; e.preventDefault(); break;
                    case 'ShiftLeft': keys.sprint = true; break;
                    case 'KeyQ':
                        if (!keys.switchWeapon && gameState.localPlayer) {
                            keys.switchWeapon = true;
                            const newWeapon = gameState.localPlayer.currentWeapon === 'gun' ? 'sword' : 'gun';
                            gameState.localPlayer.switchWeapon(newWeapon);
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.jump = false; break;
                    case 'ShiftLeft': keys.sprint = false; break;
                    case 'KeyQ': keys.switchWeapon = false; break;
                }
            });

            // Mouse click for attacking
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked || !gameState.gameStarted || !gameState.localPlayer) return;
                if (e.button === 0) { // Left click
                    gameState.localPlayer.attack(scene, camera);
                }
            });

            // Pointer lock for mouse look
            renderer.domElement.addEventListener('click', () => {
                if (gameState.gameStarted && !isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked || !gameState.gameStarted) return;

                cameraYaw -= e.movementX * 0.002;
                cameraPitch += e.movementY * 0.002; // Inverted Y-axis
                cameraPitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraPitch));
            });
        }

        // PeerJS networking
        function initPeer() {
            gameState.peer = new Peer();

            gameState.peer.on('open', (id) => {
                document.getElementById('peer-id').textContent = id;
                document.getElementById('solo-btn').disabled = false;
                document.getElementById('connect-btn').disabled = false;
                updateStatus('Ready to connect!', '');
            });

            gameState.peer.on('connection', (conn) => {
                updateStatus('Incoming connection...', 'connecting');
                handleConnection(conn);
            });

            gameState.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('Connection error: ' + err.type, 'error');
            });
        }

        function handleConnection(conn) {
            conn.on('open', () => {
                gameState.connections.push(conn);
                console.log('Connected to:', conn.peer);

                // Start game if not already started (when receiving incoming connection)
                if (!gameState.gameStarted) {
                    gameState.isHost = true;
                    startGame();
                }

                // Send existing players info to new peer
                if (gameState.localPlayer) {
                    conn.send({
                        type: 'init',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }

                // Send info about all other connected players
                gameState.players.forEach((player, id) => {
                    if (id !== conn.peer) {
                        conn.send({
                            type: 'playerJoin',
                            player: player.getNetworkData()
                        });
                    }
                });

                updatePlayerList();
            });

            conn.on('data', (data) => {
                handleNetworkData(conn.peer, data);
            });

            conn.on('close', () => {
                gameState.connections = gameState.connections.filter(c => c !== conn);
                removePlayer(conn.peer);
            });
        }

        function handleNetworkData(peerId, data) {
            switch (data.type) {
                case 'init':
                    // New player joined, create their avatar
                    if (!gameState.players.has(data.player.id)) {
                        const player = new Player(data.player.id, false, data.player.color);
                        player.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, player);
                        scene.add(player.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'update':
                    // Update player position
                    const player = gameState.players.get(data.player.id);
                    if (player) {
                        player.updateFromNetwork(data.player);
                    } else {
                        // Player not found, request init
                        const newPlayer = new Player(data.player.id, false, data.player.color);
                        newPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, newPlayer);
                        scene.add(newPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerJoin':
                    if (!gameState.players.has(data.player.id)) {
                        const joinedPlayer = new Player(data.player.id, false, data.player.color);
                        joinedPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, joinedPlayer);
                        scene.add(joinedPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerLeave':
                    removePlayer(data.id);
                    break;
            }
        }

        function removePlayer(id) {
            const player = gameState.players.get(id);
            if (player) {
                scene.remove(player.mesh);
                gameState.players.delete(id);
                updatePlayerList();
            }
        }

        function broadcast(data) {
            gameState.connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function connectToPeer() {
            const peerId = document.getElementById('connect-id').value.trim();
            if (!peerId) {
                updateStatus('Please enter a peer ID', 'error');
                return;
            }

            updateStatus('Connecting...', 'connecting');

            const conn = gameState.peer.connect(peerId, { reliable: true });
            handleConnection(conn);

            conn.on('open', () => {
                updateStatus('Connected!', 'connected');
                startGame();
            });

            conn.on('error', (err) => {
                updateStatus('Failed to connect: ' + err, 'error');
            });
        }

        function startSoloGame() {
            gameState.isHost = true;
            startGame();
        }

        function startGame() {
            gameState.gameStarted = true;

            // Create local player
            gameState.localPlayer = new Player(gameState.peer.id, true);
            gameState.players.set(gameState.peer.id, gameState.localPlayer);
            scene.add(gameState.localPlayer.mesh);

            // Hide connection panel, show HUD
            document.getElementById('connection-panel').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('controls-help').classList.remove('hidden');
            document.getElementById('minimap').classList.remove('hidden');
            document.getElementById('disconnect-btn').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('weapon-indicator').classList.remove('hidden');

            updatePlayerList();

            // Start game loop
            animate();
        }

        function disconnect() {
            // Notify all peers
            broadcast({ type: 'playerLeave', id: gameState.peer.id });

            // Close all connections
            gameState.connections.forEach(conn => conn.close());
            gameState.connections = [];

            // Reset game state
            gameState.gameStarted = false;
            gameState.players.forEach((player, id) => {
                scene.remove(player.mesh);
            });
            gameState.players.clear();
            gameState.localPlayer = null;

            // Show connection panel
            document.getElementById('connection-panel').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('controls-help').classList.add('hidden');
            document.getElementById('minimap').classList.add('hidden');
            document.getElementById('disconnect-btn').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('weapon-indicator').classList.add('hidden');

            // Exit pointer lock
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        function updatePlayerList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';

            gameState.players.forEach((player, id) => {
                const li = document.createElement('li');
                li.textContent = id.substring(0, 8) + (player.isLocal ? ' (You)' : '');
                if (player.isLocal) li.classList.add('you');
                list.appendChild(li);
            });
        }

        function copyPeerId() {
            const peerId = document.getElementById('peer-id').textContent;
            navigator.clipboard.writeText(peerId).then(() => {
                alert('Peer ID copied to clipboard!');
            });
        }

        // Minimap
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const size = 150;
            const scale = size / 100;

            ctx.clearRect(0, 0, size, size);

            // Draw background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.8)';
            ctx.fillRect(0, 0, size, size);

            // Draw obstacles
            ctx.fillStyle = 'rgba(74, 74, 106, 0.8)';
            obstacles.forEach(obs => {
                const x = (obs.position.x + 50) * scale;
                const z = (obs.position.z + 50) * scale;
                const w = obs.geometry.parameters.width * scale;
                const d = obs.geometry.parameters.depth * scale;
                ctx.fillRect(x - w/2, z - d/2, w, d);
            });

            // Draw players
            gameState.players.forEach((player, id) => {
                const x = (player.position.x + 50) * scale;
                const z = (player.position.z + 50) * scale;

                ctx.beginPath();
                ctx.arc(x, z, 4, 0, Math.PI * 2);
                ctx.fillStyle = player.isLocal ? '#4caf50' : '#' + player.color.toString(16).padStart(6, '0');
                ctx.fill();

                // Direction indicator for local player
                if (player.isLocal) {
                    const dirX = Math.sin(player.rotation.y) * 8;
                    const dirZ = Math.cos(player.rotation.y) * 8;
                    ctx.beginPath();
                    ctx.moveTo(x, z);
                    ctx.lineTo(x + dirX, z + dirZ);
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // Camera system
        function updateCamera() {
            if (!gameState.localPlayer) return;

            const player = gameState.localPlayer;
            const cameraDistance = 8;
            const cameraHeight = 3;

            // Calculate camera position based on yaw and pitch
            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraYaw) * Math.cos(cameraPitch) * cameraDistance,
                Math.sin(cameraPitch) * cameraDistance + cameraHeight,
                Math.cos(cameraYaw) * Math.cos(cameraPitch) * cameraDistance
            );

            camera.position.copy(player.position).add(cameraOffset);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        // Main game loop
        let lastNetworkUpdate = 0;
        const networkUpdateRate = 1000 / 20; // 20 updates per second

        function animate() {
            if (!gameState.gameStarted) return;

            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update local player
            if (gameState.localPlayer) {
                gameState.localPlayer.update(delta, keys, cameraYaw);

                // Update weapon indicator
                const weaponName = gameState.localPlayer.currentWeapon === 'gun' ? 'Gun' : 'Sword';
                document.getElementById('current-weapon-name').textContent = weaponName;
            }

            // Update camera
            updateCamera();

            // Animate environment (crystals, particles, etc.)
            animateEnvironment(time);

            // Network updates
            if (time * 1000 - lastNetworkUpdate > networkUpdateRate) {
                if (gameState.localPlayer && gameState.connections.length > 0) {
                    broadcast({
                        type: 'update',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }
                lastNetworkUpdate = time * 1000;
            }

            // Update minimap
            updateMinimap();

            // Render
            renderer.render(scene, camera);
        }

        // Update System
        function compareVersions(v1, v2) {
            const parts1 = v1.split('.').map(Number);
            const parts2 = v2.split('.').map(Number);

            for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
                const p1 = parts1[i] || 0;
                const p2 = parts2[i] || 0;
                if (p1 < p2) return -1;
                if (p1 > p2) return 1;
            }
            return 0;
        }

        async function checkForUpdates() {
            const btn = document.getElementById('update-btn');
            const status = document.getElementById('update-status');

            btn.disabled = true;
            btn.textContent = 'Checking...';
            status.textContent = '';
            status.className = '';

            try {
                const response = await fetch(VERSION_URL + '?t=' + Date.now()); // Cache bust
                if (!response.ok) throw new Error('Could not fetch version info');

                const data = await response.json();
                const latestVersion = data.version;
                const comparison = compareVersions(GAME_VERSION, latestVersion);

                if (comparison < 0) {
                    // Update available
                    btn.textContent = `Update to v${latestVersion}`;
                    btn.classList.add('has-update');
                    btn.disabled = false;
                    btn.onclick = () => {
                        window.location.href = GAME_URL;
                    };
                    status.textContent = `New version available! (${data.changelog || 'Bug fixes and improvements'})`;
                    status.className = 'update-available';
                } else {
                    // Up to date
                    btn.textContent = 'Check for Updates';
                    btn.classList.remove('has-update');
                    btn.disabled = false;
                    btn.onclick = checkForUpdates;
                    status.textContent = 'You have the latest version!';
                    status.className = 'up-to-date';
                }
            } catch (error) {
                console.error('Update check failed:', error);
                btn.textContent = 'Check for Updates';
                btn.disabled = false;
                btn.onclick = checkForUpdates;
                status.textContent = 'Could not check for updates (offline or repo not set up)';
                status.className = '';
            }
        }

        // Initialize everything
        function init() {
            // Display current version
            document.getElementById('current-version').textContent = GAME_VERSION;

            initScene();
            initInput();
            initPeer();

            // Auto-check for updates on load (optional)
            setTimeout(checkForUpdates, 2000);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
