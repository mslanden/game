<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #connection-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #4a4a6a;
            border-radius: 15px;
            padding: 30px;
            pointer-events: auto;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #connection-panel.hidden {
            display: none;
        }

        #connection-panel h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            background: #2a2a4a;
            color: #fff;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            border-color: #6c63ff;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6c63ff, #4a4aff);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 99, 255, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #4a4a6a;
        }

        .divider {
            text-align: center;
            color: #666;
            margin: 20px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #4a4a6a;
        }

        .divider::before {
            left: 0;
        }

        .divider::after {
            right: 0;
        }

        #your-id {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }

        #your-id label {
            color: #888;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }

        #your-id span {
            color: #6c63ff;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }

        #status.connecting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        #status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        #status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
        }

        #hud h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }

        .player-list {
            list-style: none;
        }

        .player-list li {
            padding: 5px 10px;
            background: rgba(108, 99, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .player-list li.you {
            background: rgba(76, 175, 80, 0.2);
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }

        #controls-help span {
            display: block;
            margin-bottom: 3px;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            pointer-events: none;
        }

        #disconnect-btn {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 8px 16px;
            background: rgba(244, 67, 54, 0.8);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 12px;
        }

        #disconnect-btn:hover {
            background: rgba(244, 67, 54, 1);
        }

        #disconnect-btn.hidden {
            display: none;
        }

        .copy-btn {
            background: #4a4a6a;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        .copy-btn:hover {
            background: #6c63ff;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="connection-panel">
                <h2>3D Multiplayer Arena</h2>

                <div id="your-id">
                    <label>YOUR PEER ID</label>
                    <span id="peer-id">Connecting...</span>
                    <button class="copy-btn" onclick="copyPeerId()">Copy</button>
                </div>

                <div class="input-group">
                    <label>Enter Friend's Peer ID to Connect</label>
                    <input type="text" id="connect-id" placeholder="Enter peer ID...">
                </div>

                <button id="connect-btn" class="btn btn-primary" onclick="connectToPeer()" disabled>Connect to Friend</button>

                <div class="divider">or</div>

                <button id="solo-btn" class="btn btn-secondary" onclick="startSoloGame()" disabled>Play Solo (Wait for connections)</button>

                <div id="status"></div>
            </div>

            <div id="hud" class="hidden">
                <h3>PLAYERS ONLINE</h3>
                <ul class="player-list" id="player-list"></ul>
            </div>

            <div id="controls-help" class="hidden">
                <span><b>WASD</b> - Move</span>
                <span><b>SHIFT</b> - Sprint</span>
                <span><b>SPACE</b> - Jump</span>
                <span><b>Mouse</b> - Look around</span>
                <span><b>Click</b> - Lock pointer</span>
            </div>

            <canvas id="minimap" class="hidden"></canvas>
            <button id="disconnect-btn" class="hidden" onclick="disconnect()">Disconnect</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // Game State
        const gameState = {
            players: new Map(),
            localPlayer: null,
            peer: null,
            connections: [],
            isHost: false,
            gameStarted: false
        };

        // Three.js variables
        let scene, camera, renderer, clock;
        let ground, obstacles = [];

        // Player class
        class Player {
            constructor(id, isLocal = false, color = null) {
                this.id = id;
                this.isLocal = isLocal;
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3(
                    Math.random() * 20 - 10,
                    1,
                    Math.random() * 20 - 10
                );
                this.rotation = { x: 0, y: 0 };
                this.isGrounded = true;
                this.isSprinting = false;

                // Create player mesh (body)
                const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: color || (isLocal ? 0x4caf50 : this.getRandomColor()),
                    roughness: 0.5,
                    metalness: 0.3
                });
                this.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Create head
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffdbac,
                    roughness: 0.6
                });
                this.head = new THREE.Mesh(headGeometry, headMaterial);
                this.head.position.y = 0.9;
                this.head.castShadow = true;
                this.mesh.add(this.head);

                // Create eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 0.05, 0.25);
                this.head.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 0.05, 0.25);
                this.head.add(rightEye);

                // Name tag
                this.nameTag = this.createNameTag(id.substring(0, 8));
                this.nameTag.position.y = 1.8;
                this.mesh.add(this.nameTag);

                this.mesh.position.copy(this.position);

                this.color = bodyMaterial.color.getHex();
            }

            getRandomColor() {
                const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xff9ff3, 0x54a0ff];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createNameTag(name) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.roundRect(0, 0, 256, 64, 10);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 0.5, 1);

                return sprite;
            }

            update(delta, keys, cameraYaw) {
                if (!this.isLocal) return;

                const moveSpeed = this.isSprinting ? 12 : 6;
                const jumpForce = 8;
                const gravity = 20;

                // Movement direction based on camera
                const direction = new THREE.Vector3();

                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

                    this.velocity.x = direction.x * moveSpeed;
                    this.velocity.z = direction.z * moveSpeed;

                    // Rotate player to face movement direction
                    this.rotation.y = Math.atan2(direction.x, direction.z);
                } else {
                    this.velocity.x *= 0.9;
                    this.velocity.z *= 0.9;
                }

                // Sprint
                this.isSprinting = keys.sprint && direction.length() > 0;

                // Jump
                if (keys.jump && this.isGrounded) {
                    this.velocity.y = jumpForce;
                    this.isGrounded = false;
                }

                // Apply gravity
                if (!this.isGrounded) {
                    this.velocity.y -= gravity * delta;
                }

                // Update position
                this.position.x += this.velocity.x * delta;
                this.position.y += this.velocity.y * delta;
                this.position.z += this.velocity.z * delta;

                // Ground collision
                if (this.position.y <= 1) {
                    this.position.y = 1;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                }

                // World boundaries
                const boundary = 45;
                this.position.x = Math.max(-boundary, Math.min(boundary, this.position.x));
                this.position.z = Math.max(-boundary, Math.min(boundary, this.position.z));

                // Collision with obstacles
                this.checkCollisions();

                // Update mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;
            }

            checkCollisions() {
                for (const obstacle of obstacles) {
                    const box = new THREE.Box3().setFromObject(obstacle);
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        this.position,
                        new THREE.Vector3(0.8, 2, 0.8)
                    );

                    if (box.intersectsBox(playerBox)) {
                        // Simple push-back collision
                        const obstacleCenter = new THREE.Vector3();
                        box.getCenter(obstacleCenter);

                        const pushDir = this.position.clone().sub(obstacleCenter);
                        pushDir.y = 0;
                        pushDir.normalize();

                        this.position.add(pushDir.multiplyScalar(0.1));
                    }
                }
            }

            updateFromNetwork(data) {
                if (this.isLocal) return;

                this.position.lerp(new THREE.Vector3(data.x, data.y, data.z), 0.3);
                this.rotation.y = data.ry;

                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;
            }

            getNetworkData() {
                return {
                    id: this.id,
                    x: this.position.x,
                    y: this.position.y,
                    z: this.position.z,
                    ry: this.rotation.y,
                    color: this.color
                };
            }
        }

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0x6060ff, 0x404040, 0.4);
            scene.add(hemiLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x4a4a6a, 0x3a3a5a);
            scene.add(gridHelper);

            // Create obstacles
            createObstacles();

            // Create boundary walls
            createBoundaryWalls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createObstacles() {
            const obstaclePositions = [
                { x: 10, z: 10, w: 4, h: 3, d: 4 },
                { x: -15, z: 5, w: 3, h: 5, d: 3 },
                { x: 5, z: -20, w: 6, h: 2, d: 6 },
                { x: -10, z: -15, w: 2, h: 4, d: 8 },
                { x: 20, z: -10, w: 5, h: 6, d: 2 },
                { x: -25, z: 20, w: 4, h: 3, d: 4 },
                { x: 30, z: 25, w: 3, h: 4, d: 3 },
                { x: -5, z: 30, w: 8, h: 2, d: 2 },
                { x: 15, z: -30, w: 2, h: 7, d: 2 },
                { x: -30, z: -25, w: 5, h: 3, d: 5 },
                { x: 0, z: 0, w: 2, h: 8, d: 2 },
                { x: 25, z: 15, w: 3, h: 2, d: 6 }
            ];

            const colors = [0x6c63ff, 0x4ecdc4, 0xff6b6b, 0x45b7d1, 0xf9ca24];

            obstaclePositions.forEach((pos, i) => {
                const geometry = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                const material = new THREE.MeshStandardMaterial({
                    color: colors[i % colors.length],
                    roughness: 0.6,
                    metalness: 0.3
                });
                const obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.set(pos.x, pos.h / 2, pos.z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                obstacles.push(obstacle);
            });
        }

        function createBoundaryWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a6a,
                roughness: 0.9,
                metalness: 0.1,
                transparent: true,
                opacity: 0.3
            });

            const wallHeight = 10;
            const wallThickness = 1;
            const arenaSize = 50;

            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -arenaSize);
            scene.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, arenaSize);
            scene.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            eastWall.position.set(arenaSize, wallHeight / 2, 0);
            scene.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            westWall.position.set(-arenaSize, wallHeight / 2, 0);
            scene.add(westWall);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Input handling
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            sprint: false
        };

        let cameraYaw = 0;
        let cameraPitch = 0;
        let isPointerLocked = false;

        function initInput() {
            document.addEventListener('keydown', (e) => {
                if (!gameState.gameStarted) return;

                switch (e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space': keys.jump = true; e.preventDefault(); break;
                    case 'ShiftLeft': keys.sprint = true; break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.jump = false; break;
                    case 'ShiftLeft': keys.sprint = false; break;
                }
            });

            // Pointer lock for mouse look
            renderer.domElement.addEventListener('click', () => {
                if (gameState.gameStarted && !isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked || !gameState.gameStarted) return;

                cameraYaw -= e.movementX * 0.002;
                cameraPitch -= e.movementY * 0.002;
                cameraPitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraPitch));
            });
        }

        // PeerJS networking
        function initPeer() {
            gameState.peer = new Peer();

            gameState.peer.on('open', (id) => {
                document.getElementById('peer-id').textContent = id;
                document.getElementById('solo-btn').disabled = false;
                document.getElementById('connect-btn').disabled = false;
                updateStatus('Ready to connect!', '');
            });

            gameState.peer.on('connection', (conn) => {
                updateStatus('Incoming connection...', 'connecting');
                handleConnection(conn);
            });

            gameState.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('Connection error: ' + err.type, 'error');
            });
        }

        function handleConnection(conn) {
            conn.on('open', () => {
                gameState.connections.push(conn);
                console.log('Connected to:', conn.peer);

                // Start game if not already started (when receiving incoming connection)
                if (!gameState.gameStarted) {
                    gameState.isHost = true;
                    startGame();
                }

                // Send existing players info to new peer
                if (gameState.localPlayer) {
                    conn.send({
                        type: 'init',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }

                // Send info about all other connected players
                gameState.players.forEach((player, id) => {
                    if (id !== conn.peer) {
                        conn.send({
                            type: 'playerJoin',
                            player: player.getNetworkData()
                        });
                    }
                });

                updatePlayerList();
            });

            conn.on('data', (data) => {
                handleNetworkData(conn.peer, data);
            });

            conn.on('close', () => {
                gameState.connections = gameState.connections.filter(c => c !== conn);
                removePlayer(conn.peer);
            });
        }

        function handleNetworkData(peerId, data) {
            switch (data.type) {
                case 'init':
                    // New player joined, create their avatar
                    if (!gameState.players.has(data.player.id)) {
                        const player = new Player(data.player.id, false, data.player.color);
                        player.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, player);
                        scene.add(player.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'update':
                    // Update player position
                    const player = gameState.players.get(data.player.id);
                    if (player) {
                        player.updateFromNetwork(data.player);
                    } else {
                        // Player not found, request init
                        const newPlayer = new Player(data.player.id, false, data.player.color);
                        newPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, newPlayer);
                        scene.add(newPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerJoin':
                    if (!gameState.players.has(data.player.id)) {
                        const joinedPlayer = new Player(data.player.id, false, data.player.color);
                        joinedPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, joinedPlayer);
                        scene.add(joinedPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerLeave':
                    removePlayer(data.id);
                    break;
            }
        }

        function removePlayer(id) {
            const player = gameState.players.get(id);
            if (player) {
                scene.remove(player.mesh);
                gameState.players.delete(id);
                updatePlayerList();
            }
        }

        function broadcast(data) {
            gameState.connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function connectToPeer() {
            const peerId = document.getElementById('connect-id').value.trim();
            if (!peerId) {
                updateStatus('Please enter a peer ID', 'error');
                return;
            }

            updateStatus('Connecting...', 'connecting');

            const conn = gameState.peer.connect(peerId, { reliable: true });
            handleConnection(conn);

            conn.on('open', () => {
                updateStatus('Connected!', 'connected');
                startGame();
            });

            conn.on('error', (err) => {
                updateStatus('Failed to connect: ' + err, 'error');
            });
        }

        function startSoloGame() {
            gameState.isHost = true;
            startGame();
        }

        function startGame() {
            gameState.gameStarted = true;

            // Create local player
            gameState.localPlayer = new Player(gameState.peer.id, true);
            gameState.players.set(gameState.peer.id, gameState.localPlayer);
            scene.add(gameState.localPlayer.mesh);

            // Hide connection panel, show HUD
            document.getElementById('connection-panel').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('controls-help').classList.remove('hidden');
            document.getElementById('minimap').classList.remove('hidden');
            document.getElementById('disconnect-btn').classList.remove('hidden');

            updatePlayerList();

            // Start game loop
            animate();
        }

        function disconnect() {
            // Notify all peers
            broadcast({ type: 'playerLeave', id: gameState.peer.id });

            // Close all connections
            gameState.connections.forEach(conn => conn.close());
            gameState.connections = [];

            // Reset game state
            gameState.gameStarted = false;
            gameState.players.forEach((player, id) => {
                scene.remove(player.mesh);
            });
            gameState.players.clear();
            gameState.localPlayer = null;

            // Show connection panel
            document.getElementById('connection-panel').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('controls-help').classList.add('hidden');
            document.getElementById('minimap').classList.add('hidden');
            document.getElementById('disconnect-btn').classList.add('hidden');

            // Exit pointer lock
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        function updatePlayerList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';

            gameState.players.forEach((player, id) => {
                const li = document.createElement('li');
                li.textContent = id.substring(0, 8) + (player.isLocal ? ' (You)' : '');
                if (player.isLocal) li.classList.add('you');
                list.appendChild(li);
            });
        }

        function copyPeerId() {
            const peerId = document.getElementById('peer-id').textContent;
            navigator.clipboard.writeText(peerId).then(() => {
                alert('Peer ID copied to clipboard!');
            });
        }

        // Minimap
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const size = 150;
            const scale = size / 100;

            ctx.clearRect(0, 0, size, size);

            // Draw background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.8)';
            ctx.fillRect(0, 0, size, size);

            // Draw obstacles
            ctx.fillStyle = 'rgba(74, 74, 106, 0.8)';
            obstacles.forEach(obs => {
                const x = (obs.position.x + 50) * scale;
                const z = (obs.position.z + 50) * scale;
                const w = obs.geometry.parameters.width * scale;
                const d = obs.geometry.parameters.depth * scale;
                ctx.fillRect(x - w/2, z - d/2, w, d);
            });

            // Draw players
            gameState.players.forEach((player, id) => {
                const x = (player.position.x + 50) * scale;
                const z = (player.position.z + 50) * scale;

                ctx.beginPath();
                ctx.arc(x, z, 4, 0, Math.PI * 2);
                ctx.fillStyle = player.isLocal ? '#4caf50' : '#' + player.color.toString(16).padStart(6, '0');
                ctx.fill();

                // Direction indicator for local player
                if (player.isLocal) {
                    const dirX = Math.sin(player.rotation.y) * 8;
                    const dirZ = Math.cos(player.rotation.y) * 8;
                    ctx.beginPath();
                    ctx.moveTo(x, z);
                    ctx.lineTo(x + dirX, z + dirZ);
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // Camera system
        function updateCamera() {
            if (!gameState.localPlayer) return;

            const player = gameState.localPlayer;
            const cameraDistance = 8;
            const cameraHeight = 3;

            // Calculate camera position based on yaw and pitch
            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraYaw) * Math.cos(cameraPitch) * cameraDistance,
                Math.sin(cameraPitch) * cameraDistance + cameraHeight,
                Math.cos(cameraYaw) * Math.cos(cameraPitch) * cameraDistance
            );

            camera.position.copy(player.position).add(cameraOffset);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        // Main game loop
        let lastNetworkUpdate = 0;
        const networkUpdateRate = 1000 / 20; // 20 updates per second

        function animate() {
            if (!gameState.gameStarted) return;

            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update local player
            if (gameState.localPlayer) {
                gameState.localPlayer.update(delta, keys, cameraYaw);
            }

            // Update camera
            updateCamera();

            // Network updates
            if (time * 1000 - lastNetworkUpdate > networkUpdateRate) {
                if (gameState.localPlayer && gameState.connections.length > 0) {
                    broadcast({
                        type: 'update',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }
                lastNetworkUpdate = time * 1000;
            }

            // Update minimap
            updateMinimap();

            // Render
            renderer.render(scene, camera);
        }

        // Initialize everything
        function init() {
            initScene();
            initInput();
            initPeer();
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
