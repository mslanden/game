<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The 10th Realm - Arena Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #connection-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #4a4a6a;
            border-radius: 15px;
            padding: 30px;
            pointer-events: auto;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #connection-panel.hidden {
            display: none;
        }

        #connection-panel h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            background: #2a2a4a;
            color: #fff;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            border-color: #6c63ff;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6c63ff, #4a4aff);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 99, 255, 0.4);
        }

        .btn-secondary {
            background: #3a3a5a;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #4a4a6a;
        }

        .divider {
            text-align: center;
            color: #666;
            margin: 20px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #4a4a6a;
        }

        .divider::before {
            left: 0;
        }

        .divider::after {
            right: 0;
        }

        #your-id {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
        }

        #your-id label {
            color: #888;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }

        #your-id span {
            color: #6c63ff;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }

        #status.connecting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        #status.connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        #status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
        }

        #hud h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }

        .player-list {
            list-style: none;
        }

        .player-list li {
            padding: 5px 10px;
            background: rgba(108, 99, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .player-list li.you {
            background: rgba(76, 175, 80, 0.2);
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }

        #controls-help span {
            display: block;
            margin-bottom: 3px;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            pointer-events: none;
        }

        #disconnect-btn {
            position: absolute;
            top: 20px;
            right: 190px;
            padding: 8px 16px;
            background: rgba(244, 67, 54, 0.8);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 12px;
        }

        #disconnect-btn:hover {
            background: rgba(244, 67, 54, 1);
        }

        #disconnect-btn.hidden {
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff4444;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #weapon-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #4a4a6a;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
        }

        #weapon-indicator .weapon-name {
            font-size: 18px;
            font-weight: bold;
            color: #6c63ff;
        }

        #weapon-indicator.hidden {
            display: none;
        }

        /* Health Bar HUD */
        #health-bar-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            pointer-events: none;
        }

        #health-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid #444;
            overflow: hidden;
        }

        #health-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6b6b);
            transition: width 0.2s ease;
        }

        #health-text {
            text-align: center;
            color: #fff;
            font-size: 12px;
            margin-top: 5px;
            text-shadow: 1px 1px 2px #000;
        }

        #health-bar-container.hidden {
            display: none;
        }

        /* Scoreboard */
        #scoreboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #4a4a6a;
            border-radius: 15px;
            padding: 20px;
            min-width: 400px;
            pointer-events: none;
            display: none;
            z-index: 200;
        }

        #scoreboard.visible {
            display: block;
        }

        #scoreboard h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 20px;
        }

        #scoreboard table {
            width: 100%;
            border-collapse: collapse;
        }

        #scoreboard th, #scoreboard td {
            padding: 8px 15px;
            text-align: left;
            color: #fff;
        }

        #scoreboard th {
            border-bottom: 2px solid #4a4a6a;
            color: #888;
            font-size: 12px;
        }

        #scoreboard tr.you {
            background: rgba(76, 175, 80, 0.2);
        }

        #scoreboard .kills { color: #4caf50; }
        #scoreboard .deaths { color: #ff6b6b; }

        /* Damage overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(255, 0, 0, 0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s ease;
            z-index: 50;
        }

        /* Hit marker */
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            z-index: 101;
            font-size: 30px;
            color: #ff4444;
            text-shadow: 0 0 10px #ff0000;
        }

        /* Dash indicator */
        #dash-indicator {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            color: #4ecdc4;
            font-size: 12px;
            pointer-events: none;
        }

        #dash-indicator.hidden {
            display: none;
        }

        #dash-cooldown-bar {
            width: 100px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 5px;
        }

        #dash-cooldown-fill {
            height: 100%;
            background: #4ecdc4;
            border-radius: 2px;
            width: 100%;
            transition: width 0.1s linear;
        }

        /* Death screen */
        #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 150;
            pointer-events: none;
        }

        #death-screen.visible {
            display: flex;
        }

        #death-screen h1 {
            color: #ff4444;
            font-size: 48px;
            margin-bottom: 20px;
        }

        #death-screen p {
            color: #fff;
            font-size: 18px;
        }

        #respawn-timer {
            color: #4ecdc4;
            font-size: 24px;
            margin-top: 10px;
        }

        .copy-btn {
            background: #4a4a6a;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        .copy-btn:hover {
            background: #6c63ff;
        }

        #version-info {
            text-align: center;
            color: #666;
            font-size: 11px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a5a;
        }

        /* Character Selection */
        .character-select {
            margin: 20px 0;
        }

        .character-select label {
            display: block;
            color: #aaa;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .character-option {
            background: #2a2a4a;
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .character-option:hover {
            border-color: #6c63ff;
            transform: translateY(-2px);
        }

        .character-option.selected {
            border-color: #6c63ff;
            background: rgba(108, 99, 255, 0.2);
            box-shadow: 0 0 15px rgba(108, 99, 255, 0.3);
        }

        .character-option img {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 5px;
        }

        .character-option .char-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .character-option .char-name {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #loading-overlay.hidden {
            display: none;
        }

        #loading-text {
            color: #fff;
            font-size: 24px;
            margin-bottom: 20px;
        }

        #loading-bar-container {
            width: 300px;
            height: 20px;
            background: #2a2a4a;
            border-radius: 10px;
            overflow: hidden;
        }

        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, #6c63ff, #4a4aff);
            transition: width 0.3s;
        }

        #update-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
            transition: all 0.3s;
        }

        #update-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        #update-btn:disabled {
            background: #3a3a5a;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #update-btn.has-update {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(255, 107, 107, 0); }
        }

        #update-status {
            font-size: 11px;
            margin-top: 5px;
            color: #888;
        }

        #update-status.update-available {
            color: #ff6b6b;
            font-weight: bold;
        }

        #update-status.up-to-date {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div id="loading-text">Loading Assets...</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>

    <div id="game-container">
        <div id="ui-overlay">
            <div id="connection-panel">
                <h2>The 10th Realm</h2>

                <div id="your-id">
                    <label>YOUR PEER ID</label>
                    <span id="peer-id">Connecting...</span>
                    <button class="copy-btn" onclick="copyPeerId()">Copy</button>
                </div>

                <!-- Character Selection -->
                <div class="character-select">
                    <label>Choose Your Character</label>
                    <div class="character-grid">
                        <div class="character-option selected" data-character="Knight" onclick="selectCharacter(this)">
                            <div class="char-icon">&#9876;</div>
                            <div class="char-name">Knight</div>
                        </div>
                        <div class="character-option" data-character="Barbarian" onclick="selectCharacter(this)">
                            <div class="char-icon">&#9935;</div>
                            <div class="char-name">Barbarian</div>
                        </div>
                        <div class="character-option" data-character="Mage" onclick="selectCharacter(this)">
                            <div class="char-icon">&#9733;</div>
                            <div class="char-name">Mage</div>
                        </div>
                        <div class="character-option" data-character="Ranger" onclick="selectCharacter(this)">
                            <div class="char-icon">&#127993;</div>
                            <div class="char-name">Ranger</div>
                        </div>
                        <div class="character-option" data-character="Rogue" onclick="selectCharacter(this)">
                            <div class="char-icon">&#128481;</div>
                            <div class="char-name">Rogue</div>
                        </div>
                        <div class="character-option" data-character="Rogue_Hooded" onclick="selectCharacter(this)">
                            <div class="char-icon">&#129399;</div>
                            <div class="char-name">Shadow</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Enter Friend's Peer ID to Connect</label>
                    <input type="text" id="connect-id" placeholder="Enter peer ID...">
                </div>

                <button id="connect-btn" class="btn btn-primary" onclick="connectToPeer()" disabled>Connect to Friend</button>

                <div class="divider">or</div>

                <button id="solo-btn" class="btn btn-secondary" onclick="startSoloGame()" disabled>Play Solo (Wait for connections)</button>

                <div id="status"></div>

                <div id="version-info">
                    <span>Version <span id="current-version"></span></span>
                    <br>
                    <button id="update-btn" onclick="checkForUpdates()">Check for Updates</button>
                    <div id="update-status"></div>
                </div>
            </div>

            <div id="hud" class="hidden">
                <h3>PLAYERS ONLINE</h3>
                <ul class="player-list" id="player-list"></ul>
            </div>

            <div id="controls-help" class="hidden">
                <span><b>WASD</b> - Move</span>
                <span><b>SHIFT</b> - Sprint</span>
                <span><b>SPACE</b> - Double Jump</span>
                <span><b>E</b> - Dash</span>
                <span><b>Left Click</b> - Attack</span>
                <span><b>Q</b> - Switch Weapon</span>
                <span><b>TAB</b> - Scoreboard</span>
            </div>

            <canvas id="minimap" class="hidden"></canvas>
            <button id="disconnect-btn" class="hidden" onclick="disconnect()">Disconnect</button>

            <div id="crosshair" class="hidden">
                <div class="dot"></div>
            </div>

            <div id="weapon-indicator" class="hidden">
                <div>Current Weapon</div>
                <div class="weapon-name" id="current-weapon-name">Gun</div>
            </div>

            <div id="health-bar-container" class="hidden">
                <div id="health-bar-bg">
                    <div id="health-bar-fill"></div>
                </div>
                <div id="health-text">100 / 100</div>
            </div>

            <div id="dash-indicator" class="hidden">
                <span>DASH [SHIFT]</span>
                <div id="dash-cooldown-bar">
                    <div id="dash-cooldown-fill"></div>
                </div>
            </div>

            <div id="damage-overlay"></div>
            <div id="hit-marker">X</div>

            <div id="scoreboard">
                <h2>SCOREBOARD</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Kills</th>
                            <th>Deaths</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboard-body"></tbody>
                </table>
                <p style="text-align: center; color: #666; margin-top: 15px; font-size: 11px;">Hold TAB to view</p>
            </div>

            <div id="death-screen">
                <h1>YOU DIED</h1>
                <p>Killed by <span id="killer-name">enemy</span></p>
                <div id="respawn-timer">Respawning in 3...</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/utils/SkeletonUtils.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // Game Version & Update Config
        const GAME_VERSION = "1.3.0";
        const GITHUB_USER = "mslanden";
        const GITHUB_REPO = "game";
        const VERSION_URL = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/main/version.json`;
        const GAME_URL = `https://${GITHUB_USER}.github.io/${GITHUB_REPO}/`;

        // Game State
        const gameState = {
            players: new Map(),
            localPlayer: null,
            peer: null,
            connections: [],
            isHost: false,
            gameStarted: false,
            selectedCharacter: 'Knight'
        };

        // Three.js variables
        let scene, camera, renderer, clock;
        let ground, obstacles = [];

        // Asset Management
        const assetLoader = {
            models: {},
            animations: {},
            weapons: {},
            loader: null,
            loaded: false,
            totalAssets: 0,
            loadedAssets: 0
        };

        const ASSET_PATH = 'assets/KayKit_Adventurers_2.0_FREE/';
        const CHARACTER_MODELS = ['Knight', 'Barbarian', 'Mage', 'Ranger', 'Rogue', 'Rogue_Hooded'];
        const WEAPON_MODELS = ['sword_1handed', 'axe_1handed', 'staff', 'bow', 'dagger'];

        // Character selection function
        function selectCharacter(element) {
            document.querySelectorAll('.character-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            gameState.selectedCharacter = element.dataset.character;
        }

        // Asset loading system
        async function loadAssets() {
            assetLoader.loader = new THREE.GLTFLoader();

            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');

            // Calculate total assets
            assetLoader.totalAssets = CHARACTER_MODELS.length + 2; // Characters + 2 animation files

            loadingText.textContent = 'Loading character models...';

            // Load character models
            for (const charName of CHARACTER_MODELS) {
                try {
                    const gltf = await loadGLTF(`${ASSET_PATH}Characters/gltf/${charName}.glb`);
                    gltf.scene.updateMatrixWorld(true); // Required for proper skeleton cloning
                    assetLoader.models[charName] = gltf;
                    assetLoader.loadedAssets++;
                    updateLoadingProgress(loadingBar, loadingText, `Loading ${charName}...`);
                } catch (error) {
                    console.warn(`Could not load ${charName} model:`, error);
                    assetLoader.loadedAssets++;
                    updateLoadingProgress(loadingBar, loadingText, `Skipping ${charName}...`);
                }
            }

            // Load animations
            loadingText.textContent = 'Loading animations...';
            try {
                const generalAnims = await loadGLTF(`${ASSET_PATH}Animations/gltf/Rig_Medium/Rig_Medium_General.glb`);
                assetLoader.animations.general = generalAnims;
                assetLoader.loadedAssets++;
                updateLoadingProgress(loadingBar, loadingText, 'Loading animations...');
            } catch (error) {
                console.warn('Could not load general animations:', error);
                assetLoader.loadedAssets++;
            }

            try {
                const movementAnims = await loadGLTF(`${ASSET_PATH}Animations/gltf/Rig_Medium/Rig_Medium_MovementBasic.glb`);
                assetLoader.animations.movement = movementAnims;
                assetLoader.loadedAssets++;
                updateLoadingProgress(loadingBar, loadingText, 'Loading movement...');
            } catch (error) {
                console.warn('Could not load movement animations:', error);
                assetLoader.loadedAssets++;
            }

            // Load weapon models
            loadingText.textContent = 'Loading weapons...';
            for (const weaponName of WEAPON_MODELS) {
                try {
                    const gltf = await loadGLTF(`${ASSET_PATH}Assets/gltf/${weaponName}.gltf`);
                    assetLoader.weapons[weaponName] = gltf;
                    updateLoadingProgress(loadingBar, loadingText, `Loading ${weaponName}...`);
                } catch (error) {
                    console.warn(`Could not load ${weaponName}:`, error);
                }
            }

            assetLoader.loaded = true;
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        function loadGLTF(path) {
            return new Promise((resolve, reject) => {
                // Timeout after 10 seconds
                const timeout = setTimeout(() => {
                    console.warn(`Timeout loading: ${path}`);
                    reject(new Error('Load timeout'));
                }, 10000);

                assetLoader.loader.load(
                    path,
                    (gltf) => {
                        clearTimeout(timeout);
                        console.log(`Loaded: ${path}`);
                        resolve(gltf);
                    },
                    (progress) => {
                        // Progress callback
                    },
                    (error) => {
                        clearTimeout(timeout);
                        console.warn(`Failed to load: ${path}`, error);
                        reject(error);
                    }
                );
            });
        }

        function updateLoadingProgress(bar, text, message) {
            const progress = (assetLoader.loadedAssets / assetLoader.totalAssets) * 100;
            bar.style.width = `${progress}%`;
            text.textContent = message;
        }

        // Player class
        class Player {
            constructor(id, isLocal = false, color = null, characterType = 'Knight') {
                this.id = id;
                this.isLocal = isLocal;
                this.characterType = characterType;
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3(
                    Math.random() * 20 - 10,
                    0,
                    Math.random() * 20 - 10
                );
                this.rotation = { x: 0, y: 0 };
                this.isGrounded = true;
                this.isSprinting = false;
                this.jumpCount = 0;
                this.maxJumps = 2; // Double jump enabled
                this.currentWeapon = 'gun'; // 'gun' or 'sword'
                this.isAttacking = false;
                this.attackCooldown = 0;

                // Health system
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.isDead = false;
                this.respawnTime = 3;

                // Combat stats
                this.kills = 0;
                this.deaths = 0;

                // Dash system
                this.dashCooldown = 0;
                this.maxDashCooldown = 2;
                this.isDashing = false;
                this.dashDuration = 0;
                this.dashDirection = new THREE.Vector3();

                // Animation system
                this.mixer = null;
                this.animations = {};
                this.currentAnimation = null;

                // Create a container group for the player
                this.mesh = new THREE.Group();

                // Try to use 3D model, fallback to procedural
                const modelData = assetLoader.models[characterType];
                if (modelData && modelData.scene) {
                    // Clone the loaded model using SkeletonUtils for skinned meshes
                    this.characterModel = THREE.SkeletonUtils.clone(modelData.scene);
                    this.characterModel.scale.set(0.5, 0.5, 0.5);
                    this.characterModel.position.y = 0;

                    // Load and apply texture
                    const textureLoader = new THREE.TextureLoader();
                    const textureName = characterType.toLowerCase().replace('_hooded', '') + '_texture.png';
                    const texturePath = `${ASSET_PATH}Characters/gltf/${textureName}`;

                    const texture = textureLoader.load(texturePath);
                    texture.flipY = false; // GLTF models typically need this
                    texture.encoding = THREE.sRGBEncoding;

                    // Apply texture and shadows to meshes
                    this.characterModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.material = new THREE.MeshStandardMaterial({
                                map: texture,
                                roughness: 0.8,
                                metalness: 0.2
                            });
                        }
                    });

                    this.mesh.add(this.characterModel);

                    // Set up animation mixer
                    this.mixer = new THREE.AnimationMixer(this.characterModel);

                    // Load animations from the animation files
                    this.setupAnimations();

                    this.using3DModel = true;
                } else {
                    // Fallback: Create procedural player mesh (body)
                    const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
                    const bodyMaterial = new THREE.MeshStandardMaterial({
                        color: color || (isLocal ? 0x4caf50 : this.getRandomColor()),
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    body.receiveShadow = true;
                    this.mesh.add(body);

                    // Create head
                    const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const headMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffdbac,
                        roughness: 0.6
                    });
                    this.head = new THREE.Mesh(headGeometry, headMaterial);
                    this.head.position.y = 1.9;
                    this.head.castShadow = true;
                    this.mesh.add(this.head);

                    // Create eyes
                    const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                    const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

                    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    leftEye.position.set(-0.1, 0.05, 0.25);
                    this.head.add(leftEye);

                    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    rightEye.position.set(0.1, 0.05, 0.25);
                    this.head.add(rightEye);

                    this.using3DModel = false;
                }

                // Create weapons (attached to hands or floating beside)
                this.createWeapons();

                // Name tag
                this.nameTag = this.createNameTag(id.substring(0, 8));
                this.nameTag.position.y = this.using3DModel ? 2.2 : 2.5;
                this.mesh.add(this.nameTag);

                // Health bar above player
                this.healthBar = this.createHealthBar();
                this.healthBar.position.y = this.using3DModel ? 2.5 : 2.8;
                this.mesh.add(this.healthBar);

                this.mesh.position.copy(this.position);

                // Store color for reference
                this.color = color || (isLocal ? 0x4caf50 : this.getRandomColor());
            }

            setupAnimations() {
                // Load animations from the animation files
                const animationNames = [];

                if (assetLoader.animations.movement && assetLoader.animations.movement.animations) {
                    assetLoader.animations.movement.animations.forEach(clip => {
                        const action = this.mixer.clipAction(clip);
                        this.animations[clip.name.toLowerCase()] = action;
                        animationNames.push(clip.name);
                    });
                }

                if (assetLoader.animations.general && assetLoader.animations.general.animations) {
                    assetLoader.animations.general.animations.forEach(clip => {
                        const action = this.mixer.clipAction(clip);
                        this.animations[clip.name.toLowerCase()] = action;
                        animationNames.push(clip.name);
                    });
                }

                // Try to play idle animation
                this.playAnimation('idle');
            }

            playAnimation(name, options = {}) {
                // Map common names to KayKit animation names
                const animationMap = {
                    'idle': ['idle_a', 'idle_b'],
                    'walk': ['walking_a', 'walking_b', 'walking_c'],
                    'run': ['running_a', 'running_b'],
                    'jump': ['jump_full_short', 'jump_start', 'jump_idle'],
                    'death': ['death_a', 'death_b'],
                    'hit': ['hit_a', 'hit_b']
                };

                const animName = name.toLowerCase();

                // Check direct match first
                if (this.animations[animName]) {
                    this.playAnimationAction(this.animations[animName], options);
                    return;
                }

                // Check mapped variations
                const variations = animationMap[animName] || [`${animName}_a`, `${animName}_b`];
                for (const varName of variations) {
                    if (this.animations[varName]) {
                        this.playAnimationAction(this.animations[varName], options);
                        return;
                    }
                }

                // Fallback to idle
                if (this.animations['idle_a']) {
                    this.playAnimationAction(this.animations['idle_a'], options);
                }
            }

            playAnimationAction(action, options = {}) {
                if (this.currentAnimation === action) return;

                if (this.currentAnimation) {
                    this.currentAnimation.fadeOut(0.2);
                }

                action.reset();
                action.fadeIn(0.2);
                action.play();

                if (options.loop === false) {
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                }

                this.currentAnimation = action;
            }

            updateAnimation(delta) {
                if (this.mixer) {
                    this.mixer.update(delta);
                }
            }

            createHealthBar() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 16;
                this.healthBarCtx = canvas;

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(1.5, 0.2, 1);

                this.healthBarTexture = texture;
                this.updateHealthBar();

                return sprite;
            }

            updateHealthBar() {
                const canvas = this.healthBarCtx;
                const ctx = canvas.getContext('2d');
                const healthPercent = this.health / this.maxHealth;

                ctx.clearRect(0, 0, 128, 16);

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 128, 16);

                // Health fill
                const gradient = ctx.createLinearGradient(0, 0, 128 * healthPercent, 0);
                if (healthPercent > 0.5) {
                    gradient.addColorStop(0, '#4caf50');
                    gradient.addColorStop(1, '#8bc34a');
                } else if (healthPercent > 0.25) {
                    gradient.addColorStop(0, '#ff9800');
                    gradient.addColorStop(1, '#ffc107');
                } else {
                    gradient.addColorStop(0, '#f44336');
                    gradient.addColorStop(1, '#ff5722');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(2, 2, (128 - 4) * healthPercent, 12);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(1, 1, 126, 14);

                if (this.healthBarTexture) {
                    this.healthBarTexture.needsUpdate = true;
                }
            }

            takeDamage(amount, attackerId) {
                if (this.isDead) return;

                this.health = Math.max(0, this.health - amount);
                this.updateHealthBar();

                if (this.isLocal) {
                    updateLocalHealthBar(this.health, this.maxHealth);
                    showDamageOverlay();
                    shakeScreen();
                }

                if (this.health <= 0) {
                    this.die(attackerId);
                }

                // Network health update
                if (this.isLocal) {
                    broadcast({
                        type: 'damage',
                        targetId: this.id,
                        health: this.health,
                        attackerId: attackerId
                    });
                }
            }

            die(killerId) {
                this.isDead = true;
                this.deaths++;
                this.mesh.visible = false;

                // Give kill credit
                if (killerId && killerId !== this.id) {
                    const killer = gameState.players.get(killerId);
                    if (killer) {
                        killer.kills++;
                    }
                }

                // Create death particles
                createDeathParticles(this.position.clone());

                if (this.isLocal) {
                    showDeathScreen(killerId);
                    setTimeout(() => this.respawn(), this.respawnTime * 1000);
                }

                // Network death
                if (this.isLocal) {
                    broadcast({
                        type: 'death',
                        playerId: this.id,
                        killerId: killerId
                    });
                }
            }

            respawn() {
                this.health = this.maxHealth;
                this.isDead = false;
                this.position.set(
                    Math.random() * 40 - 20,
                    1,
                    Math.random() * 40 - 20
                );
                this.velocity.set(0, 0, 0);
                this.mesh.visible = true;
                this.updateHealthBar();

                if (this.isLocal) {
                    updateLocalHealthBar(this.health, this.maxHealth);
                    hideDeathScreen();
                }

                // Network respawn
                if (this.isLocal) {
                    broadcast({
                        type: 'respawn',
                        playerId: this.id,
                        x: this.position.x,
                        y: this.position.y,
                        z: this.position.z
                    });
                }
            }

            dash(direction) {
                if (this.dashCooldown > 0 || this.isDead || direction.length() === 0) return;

                this.isDashing = true;
                this.dashDuration = 0.15;
                this.dashDirection.copy(direction).normalize();
                this.dashCooldown = this.maxDashCooldown;

                // Create dash trail effect
                createDashTrail(this.position.clone(), this.color);
            }

            getRandomColor() {
                const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xff9ff3, 0x54a0ff];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createNameTag(name) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.roundRect(0, 0, 256, 64, 10);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 0.5, 1);

                return sprite;
            }

            createWeapons() {
                // Gun weapon
                const gunGroup = new THREE.Group();

                // Gun body (main barrel)
                const gunBody = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.12, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.3 })
                );
                gunGroup.add(gunBody);

                // Gun handle
                const gunHandle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.2, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 })
                );
                gunHandle.position.set(0, -0.12, -0.1);
                gunHandle.rotation.x = -0.3;
                gunGroup.add(gunHandle);

                // Gun barrel tip (muzzle)
                const muzzle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.04, 0.08, 8),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.95, roughness: 0.2 })
                );
                muzzle.rotation.x = Math.PI / 2;
                muzzle.position.set(0, 0, 0.28);
                gunGroup.add(muzzle);

                // Gun sight
                const sight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.04, 0.02),
                    new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0xff0000, emissiveIntensity: 0.5 })
                );
                sight.position.set(0, 0.08, -0.05);
                gunGroup.add(sight);

                // Position based on model type
                if (this.using3DModel) {
                    gunGroup.position.set(0.35, 1.0, 0.3);
                } else {
                    gunGroup.position.set(0.4, 0.2, 0.3);
                }
                gunGroup.rotation.y = 0.1;
                this.gun = gunGroup;
                this.mesh.add(this.gun);

                // Melee weapon (sword/axe/staff/dagger based on character)
                const meleeGroup = new THREE.Group();

                // Map character types to weapons
                const characterWeapons = {
                    'Knight': 'sword_1handed',
                    'Barbarian': 'axe_1handed',
                    'Mage': 'staff',
                    'Ranger': 'bow',
                    'Rogue': 'dagger',
                    'Rogue_Hooded': 'dagger'
                };

                const weaponName = characterWeapons[this.characterType] || 'sword_1handed';
                const weaponData = assetLoader.weapons[weaponName];

                if (weaponData && weaponData.scene && this.using3DModel) {
                    // Use loaded 3D weapon
                    const weaponModel = weaponData.scene.clone();
                    weaponModel.scale.set(0.5, 0.5, 0.5);

                    // Adjust rotation based on weapon type
                    if (weaponName === 'staff') {
                        weaponModel.rotation.x = Math.PI / 2;
                    } else if (weaponName === 'bow') {
                        weaponModel.rotation.z = Math.PI / 2;
                    }

                    weaponModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                        }
                    });
                    meleeGroup.add(weaponModel);
                } else {
                    // Fallback procedural sword
                    const bladeGeometry = new THREE.BoxGeometry(0.06, 0.04, 1.0);
                    const bladeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xc0c0c0,
                        metalness: 0.95,
                        roughness: 0.1
                    });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    blade.position.z = 0.5;
                    meleeGroup.add(blade);

                    const handleGeom = new THREE.CylinderGeometry(0.03, 0.035, 0.25, 8);
                    const handleMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
                    const handle = new THREE.Mesh(handleGeom, handleMat);
                    handle.rotation.x = Math.PI / 2;
                    handle.position.z = -0.12;
                    meleeGroup.add(handle);
                }

                // Position based on model type
                if (this.using3DModel) {
                    meleeGroup.position.set(0.3, 0.8, 0.2);
                    meleeGroup.rotation.set(0, 0, -Math.PI / 6);
                } else {
                    meleeGroup.position.set(0.4, 0.2, 0.3);
                    meleeGroup.rotation.x = 0.2;
                }
                this.sword = meleeGroup;
                this.sword.visible = false;
                this.mesh.add(this.sword);

                // Muzzle flash (for gun)
                const flashGeom = new THREE.SphereGeometry(0.1, 8, 8);
                const flashMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0
                });
                this.muzzleFlash = new THREE.Mesh(flashGeom, flashMat);
                this.muzzleFlash.position.set(0, 0, 0.35);
                this.gun.add(this.muzzleFlash);
            }

            switchWeapon(weapon) {
                this.currentWeapon = weapon;
                this.gun.visible = weapon === 'gun';
                this.sword.visible = weapon === 'sword';
            }

            attack(scene, camera) {
                if (this.attackCooldown > 0 || !this.isLocal) return;

                this.isAttacking = true;

                if (this.currentWeapon === 'gun') {
                    this.attackCooldown = 0.25; // Fire rate
                    this.shootGun(scene, camera);
                } else {
                    this.attackCooldown = 0.5; // Swing rate
                    this.swingSword();
                }
            }

            shootGun(scene, camera) {
                const GUN_DAMAGE = 20;

                // Muzzle flash
                this.muzzleFlash.material.opacity = 1;
                setTimeout(() => {
                    if (this.muzzleFlash) this.muzzleFlash.material.opacity = 0;
                }, 50);

                // Get shooting direction from camera
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                // Start position at gun muzzle
                const startPos = this.mesh.position.clone();
                startPos.y += 0.7;
                startPos.add(direction.clone().multiplyScalar(0.8));

                // Raycast for hit detection
                const raycaster = new THREE.Raycaster(startPos, direction, 0, 100);
                let hitPlayer = null;
                let hitDistance = Infinity;

                gameState.players.forEach((player, id) => {
                    if (id === this.id || player.isDead) return;

                    // Create bounding box for player
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        player.position,
                        new THREE.Vector3(1, 2, 1)
                    );

                    const ray = new THREE.Ray(startPos, direction);
                    const intersection = new THREE.Vector3();

                    if (ray.intersectsBox(playerBox, intersection)) {
                        const dist = startPos.distanceTo(intersection);
                        if (dist < hitDistance) {
                            hitDistance = dist;
                            hitPlayer = player;
                        }
                    }
                });

                // Deal damage if hit
                if (hitPlayer) {
                    hitPlayer.takeDamage(GUN_DAMAGE, this.id);
                    showHitMarker();
                    createDamageNumber(hitPlayer.position.clone(), GUN_DAMAGE);
                }

                // Create bullet tracer
                const bulletGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
                const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const bullet = new THREE.Mesh(bulletGeom, bulletMat);

                bullet.position.copy(startPos);
                bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                scene.add(bullet);

                // Animate bullet
                const speed = 80;
                const maxDistance = hitPlayer ? hitDistance : 100;
                let traveled = 0;

                const animateBullet = () => {
                    if (traveled >= maxDistance) {
                        scene.remove(bullet);
                        return;
                    }
                    bullet.position.add(direction.clone().multiplyScalar(speed * 0.016));
                    traveled += speed * 0.016;
                    requestAnimationFrame(animateBullet);
                };
                animateBullet();
            }

            swingSword() {
                const SWORD_DAMAGE = 35;
                const SWORD_RANGE = 3;

                // Check for players in melee range
                gameState.players.forEach((player, id) => {
                    if (id === this.id || player.isDead) return;

                    const distance = this.position.distanceTo(player.position);
                    if (distance <= SWORD_RANGE) {
                        // Check if player is in front (within ~90 degree cone)
                        const toPlayer = player.position.clone().sub(this.position).normalize();
                        const forward = new THREE.Vector3(
                            Math.sin(this.rotation.y),
                            0,
                            Math.cos(this.rotation.y)
                        );
                        const dot = toPlayer.dot(forward);

                        if (dot > 0.3) { // In front
                            player.takeDamage(SWORD_DAMAGE, this.id);
                            showHitMarker();
                            createDamageNumber(player.position.clone(), SWORD_DAMAGE);
                        }
                    }
                });

                // Sword swing animation
                const startRotation = this.sword.rotation.x;
                const swingAmount = -Math.PI / 2;
                let progress = 0;

                const animateSwing = () => {
                    progress += 0.15;
                    if (progress <= 1) {
                        const swing = Math.sin(progress * Math.PI) * swingAmount;
                        this.sword.rotation.x = startRotation + swing;
                        requestAnimationFrame(animateSwing);
                    } else {
                        this.sword.rotation.x = startRotation;
                        this.isAttacking = false;
                    }
                };
                animateSwing();
            }

            update(delta, keys, cameraYaw) {
                if (!this.isLocal || this.isDead) return;

                const moveSpeed = this.isSprinting ? 12 : 6;
                const dashSpeed = 40;
                const jumpForce = 8;
                const gravity = 20;

                // Update dash cooldown
                if (this.dashCooldown > 0) {
                    this.dashCooldown -= delta;
                }

                // Movement direction based on camera
                const direction = new THREE.Vector3();

                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

                    // Rotate player to face movement direction
                    this.rotation.y = Math.atan2(direction.x, direction.z);
                }

                // Dash (Shift + direction, not sprinting)
                if (keys.dash && !this.isDashing && direction.length() > 0) {
                    this.dash(direction);
                }

                // Handle dashing
                if (this.isDashing) {
                    this.dashDuration -= delta;
                    this.velocity.x = this.dashDirection.x * dashSpeed;
                    this.velocity.z = this.dashDirection.z * dashSpeed;

                    if (this.dashDuration <= 0) {
                        this.isDashing = false;
                    }
                } else if (direction.length() > 0) {
                    this.velocity.x = direction.x * moveSpeed;
                    this.velocity.z = direction.z * moveSpeed;
                } else {
                    this.velocity.x *= 0.9;
                    this.velocity.z *= 0.9;
                }

                // Sprint (only when not dashing)
                this.isSprinting = keys.sprint && direction.length() > 0 && !this.isDashing;

                // Jump (with double jump)
                if (keys.jump && !keys.jumpHeld && this.jumpCount < this.maxJumps) {
                    this.velocity.y = jumpForce;
                    this.jumpCount++;
                    this.isGrounded = false;
                    keys.jumpHeld = true;
                }
                if (!keys.jump) {
                    keys.jumpHeld = false;
                }

                // Apply gravity
                if (!this.isGrounded) {
                    this.velocity.y -= gravity * delta;
                }

                // Update position
                this.position.x += this.velocity.x * delta;
                this.position.y += this.velocity.y * delta;
                this.position.z += this.velocity.z * delta;

                // Ground collision (adjust for 3D models that are at y=0)
                const groundLevel = this.using3DModel ? 0 : 1;
                if (this.position.y <= groundLevel) {
                    this.position.y = groundLevel;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    this.jumpCount = 0; // Reset double jump
                }

                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }

                // World boundaries
                const boundary = 45;
                this.position.x = Math.max(-boundary, Math.min(boundary, this.position.x));
                this.position.z = Math.max(-boundary, Math.min(boundary, this.position.z));

                // Collision with obstacles
                this.checkCollisions();

                // Update mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;

                // Update animation based on state
                if (this.using3DModel && this.mixer) {
                    const isMoving = Math.abs(this.velocity.x) > 0.5 || Math.abs(this.velocity.z) > 0.5;
                    const isInAir = !this.isGrounded;

                    let targetAnim = 'idle';
                    if (isInAir) {
                        targetAnim = 'jump';
                    } else if (this.isDashing) {
                        targetAnim = 'run';
                    } else if (isMoving) {
                        targetAnim = this.isSprinting ? 'run' : 'walk';
                    }

                    this.playAnimation(targetAnim);
                }
            }

            checkCollisions() {
                for (const obstacle of obstacles) {
                    const box = new THREE.Box3().setFromObject(obstacle);
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        this.position,
                        new THREE.Vector3(0.8, 2, 0.8)
                    );

                    if (box.intersectsBox(playerBox)) {
                        // Simple push-back collision
                        const obstacleCenter = new THREE.Vector3();
                        box.getCenter(obstacleCenter);

                        const pushDir = this.position.clone().sub(obstacleCenter);
                        pushDir.y = 0;
                        pushDir.normalize();

                        this.position.add(pushDir.multiplyScalar(0.1));
                    }
                }
            }

            updateFromNetwork(data) {
                if (this.isLocal) return;

                this.position.lerp(new THREE.Vector3(data.x, data.y, data.z), 0.3);
                this.rotation.y = data.ry;

                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;
            }

            getNetworkData() {
                return {
                    id: this.id,
                    x: this.position.x,
                    y: this.position.y,
                    z: this.position.z,
                    ry: this.rotation.y,
                    color: this.color,
                    characterType: this.characterType
                };
            }
        }

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0x6060ff, 0x404040, 0.4);
            scene.add(hemiLight);

            // Ground with better visuals
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a3a,
                roughness: 0.9,
                metalness: 0.1
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x4a4a6a, 0x3a3a5a);
            scene.add(gridHelper);

            // Create obstacles
            createObstacles();

            // Create boundary walls
            createBoundaryWalls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function createObstacles() {
            // Tree positions with types: 'pine', 'oak', 'willow', 'dead'
            const treePositions = [
                { x: 10, z: 10, type: 'oak', scale: 1.2 },
                { x: -15, z: 5, type: 'pine', scale: 1.5 },
                { x: 5, z: -20, type: 'willow', scale: 1.0 },
                { x: -10, z: -15, type: 'pine', scale: 1.8 },
                { x: 20, z: -10, type: 'oak', scale: 1.0 },
                { x: -25, z: 20, type: 'dead', scale: 1.3 },
                { x: 30, z: 25, type: 'pine', scale: 1.4 },
                { x: -5, z: 30, type: 'oak', scale: 0.9 },
                { x: 15, z: -30, type: 'pine', scale: 2.0 },
                { x: -30, z: -25, type: 'willow', scale: 1.1 },
                { x: 0, z: 0, type: 'oak', scale: 1.6 },
                { x: 25, z: 15, type: 'dead', scale: 1.0 },
                { x: -20, z: -5, type: 'pine', scale: 1.3 },
                { x: 35, z: -20, type: 'oak', scale: 1.1 },
                { x: -35, z: 10, type: 'willow', scale: 1.2 },
                { x: 12, z: 35, type: 'pine', scale: 1.7 },
                { x: -8, z: -35, type: 'dead', scale: 0.9 },
                { x: 40, z: 5, type: 'oak', scale: 1.0 }
            ];

            treePositions.forEach(pos => {
                const tree = createTree(pos.type, pos.scale);
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
                obstacles.push(tree);
            });
        }

        function createTree(type, scale) {
            const treeGroup = new THREE.Group();

            // Trunk colors based on type
            const trunkColors = {
                pine: 0x4a3728,
                oak: 0x5c4033,
                willow: 0x6b5344,
                dead: 0x3d3d3d
            };

            // Leaf colors based on type
            const leafColors = {
                pine: 0x2d5a27,
                oak: 0x4a7c3f,
                willow: 0x6b8e4e,
                dead: null
            };

            const trunkColor = trunkColors[type];
            const leafColor = leafColors[type];

            if (type === 'pine') {
                // Pine tree - tall trunk with cone-shaped layers
                const trunkHeight = 3 * scale;
                const trunkGeom = new THREE.CylinderGeometry(0.2 * scale, 0.35 * scale, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                // Multiple cone layers for pine
                const leafMat = new THREE.MeshStandardMaterial({ color: leafColor, roughness: 0.8 });
                for (let i = 0; i < 4; i++) {
                    const coneSize = (1.8 - i * 0.3) * scale;
                    const coneHeight = 2 * scale;
                    const cone = new THREE.Mesh(
                        new THREE.ConeGeometry(coneSize, coneHeight, 8),
                        leafMat
                    );
                    cone.position.y = trunkHeight + i * 1.2 * scale;
                    cone.castShadow = true;
                    cone.receiveShadow = true;
                    treeGroup.add(cone);
                }

            } else if (type === 'oak') {
                // Oak tree - thick trunk with round bushy top
                const trunkHeight = 2.5 * scale;
                const trunkGeom = new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                // Bushy foliage - multiple spheres
                const leafMat = new THREE.MeshStandardMaterial({ color: leafColor, roughness: 0.8 });
                const foliagePositions = [
                    { x: 0, y: trunkHeight + 1 * scale, z: 0, r: 1.5 * scale },
                    { x: 0.8 * scale, y: trunkHeight + 0.5 * scale, z: 0.5 * scale, r: 1 * scale },
                    { x: -0.7 * scale, y: trunkHeight + 0.6 * scale, z: 0.6 * scale, r: 1.1 * scale },
                    { x: 0.3 * scale, y: trunkHeight + 0.4 * scale, z: -0.8 * scale, r: 1 * scale },
                    { x: -0.5 * scale, y: trunkHeight + 1.2 * scale, z: -0.3 * scale, r: 0.9 * scale }
                ];
                foliagePositions.forEach(fp => {
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(fp.r, 8, 6),
                        leafMat
                    );
                    foliage.position.set(fp.x, fp.y, fp.z);
                    foliage.castShadow = true;
                    foliage.receiveShadow = true;
                    treeGroup.add(foliage);
                });

            } else if (type === 'willow') {
                // Willow tree - curved trunk with drooping branches
                const trunkHeight = 3 * scale;
                const trunkGeom = new THREE.CylinderGeometry(0.25 * scale, 0.4 * scale, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                // Main canopy
                const leafMat = new THREE.MeshStandardMaterial({
                    color: leafColor,
                    roughness: 0.7,
                    transparent: true,
                    opacity: 0.9
                });
                const canopy = new THREE.Mesh(
                    new THREE.SphereGeometry(2 * scale, 8, 6),
                    leafMat
                );
                canopy.position.y = trunkHeight + 0.5 * scale;
                canopy.scale.y = 0.6;
                canopy.castShadow = true;
                treeGroup.add(canopy);

                // Drooping vines/branches
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const vineGeom = new THREE.CylinderGeometry(0.05 * scale, 0.02 * scale, 2.5 * scale, 4);
                    const vine = new THREE.Mesh(vineGeom, leafMat);
                    vine.position.set(
                        Math.cos(angle) * 1.5 * scale,
                        trunkHeight - 0.5 * scale,
                        Math.sin(angle) * 1.5 * scale
                    );
                    vine.rotation.x = Math.random() * 0.3;
                    vine.rotation.z = Math.random() * 0.3;
                    treeGroup.add(vine);
                }

            } else if (type === 'dead') {
                // Dead tree - bare trunk with twisted branches
                const trunkHeight = 3.5 * scale;
                const trunkGeom = new THREE.CylinderGeometry(0.15 * scale, 0.4 * scale, trunkHeight, 6);
                const trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 1.0 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.rotation.z = 0.1;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                // Bare branches
                for (let i = 0; i < 5; i++) {
                    const branchLength = (1 + Math.random()) * scale;
                    const branch = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03 * scale, 0.08 * scale, branchLength, 4),
                        trunkMat
                    );
                    const angle = (i / 5) * Math.PI * 2 + Math.random() * 0.5;
                    const height = trunkHeight * (0.5 + Math.random() * 0.4);
                    branch.position.set(
                        Math.cos(angle) * 0.3 * scale,
                        height,
                        Math.sin(angle) * 0.3 * scale
                    );
                    branch.rotation.z = Math.cos(angle) * 0.8;
                    branch.rotation.x = Math.sin(angle) * 0.8;
                    branch.castShadow = true;
                    treeGroup.add(branch);
                }
            }

            return treeGroup;
        }

        function createBoundaryWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a6a,
                roughness: 0.9,
                metalness: 0.1,
                transparent: true,
                opacity: 0.3
            });

            const wallHeight = 10;
            const wallThickness = 1;
            const arenaSize = 50;

            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight / 2, -arenaSize);
            scene.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(arenaSize * 2, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight / 2, arenaSize);
            scene.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            eastWall.position.set(arenaSize, wallHeight / 2, 0);
            scene.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize * 2),
                wallMaterial
            );
            westWall.position.set(-arenaSize, wallHeight / 2, 0);
            scene.add(westWall);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Input handling
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            jumpHeld: false,
            sprint: false,
            attack: false,
            switchWeapon: false,
            dash: false,
            scoreboard: false
        };

        let cameraYaw = 0;
        let cameraPitch = 0;
        let isPointerLocked = false;

        function initInput() {
            document.addEventListener('keydown', (e) => {
                if (!gameState.gameStarted) return;

                switch (e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space': keys.jump = true; e.preventDefault(); break;
                    case 'ShiftLeft': keys.sprint = true; break;
                    case 'KeyQ':
                        if (!keys.switchWeapon && gameState.localPlayer) {
                            keys.switchWeapon = true;
                            const newWeapon = gameState.localPlayer.currentWeapon === 'gun' ? 'sword' : 'gun';
                            gameState.localPlayer.switchWeapon(newWeapon);
                        }
                        break;
                    case 'ShiftRight':
                    case 'KeyE':
                        keys.dash = true;
                        break;
                    case 'Tab':
                        e.preventDefault();
                        keys.scoreboard = true;
                        document.getElementById('scoreboard').classList.add('visible');
                        updateScoreboard();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.jump = false; break;
                    case 'ShiftLeft': keys.sprint = false; break;
                    case 'KeyQ': keys.switchWeapon = false; break;
                    case 'ShiftRight':
                    case 'KeyE':
                        keys.dash = false;
                        break;
                    case 'Tab':
                        keys.scoreboard = false;
                        document.getElementById('scoreboard').classList.remove('visible');
                        break;
                }
            });

            // Mouse click for attacking
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked || !gameState.gameStarted || !gameState.localPlayer) return;
                if (e.button === 0) { // Left click
                    gameState.localPlayer.attack(scene, camera);
                }
            });

            // Pointer lock for mouse look
            renderer.domElement.addEventListener('click', () => {
                if (gameState.gameStarted && !isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked || !gameState.gameStarted) return;

                cameraYaw -= e.movementX * 0.002;
                cameraPitch += e.movementY * 0.002; // Inverted Y-axis
                cameraPitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraPitch));
            });
        }

        // PeerJS networking
        function initPeer() {
            gameState.peer = new Peer();

            gameState.peer.on('open', (id) => {
                document.getElementById('peer-id').textContent = id;
                document.getElementById('solo-btn').disabled = false;
                document.getElementById('connect-btn').disabled = false;
                updateStatus('Ready to connect!', '');
            });

            gameState.peer.on('connection', (conn) => {
                updateStatus('Incoming connection...', 'connecting');
                handleConnection(conn);
            });

            gameState.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('Connection error: ' + err.type, 'error');
            });
        }

        function handleConnection(conn) {
            conn.on('open', () => {
                gameState.connections.push(conn);
                console.log('Connected to:', conn.peer);

                // Start game if not already started (when receiving incoming connection)
                if (!gameState.gameStarted) {
                    gameState.isHost = true;
                    startGame();
                }

                // Send existing players info to new peer
                if (gameState.localPlayer) {
                    conn.send({
                        type: 'init',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }

                // Send info about all other connected players
                gameState.players.forEach((player, id) => {
                    if (id !== conn.peer) {
                        conn.send({
                            type: 'playerJoin',
                            player: player.getNetworkData()
                        });
                    }
                });

                updatePlayerList();
            });

            conn.on('data', (data) => {
                handleNetworkData(conn.peer, data);
            });

            conn.on('close', () => {
                gameState.connections = gameState.connections.filter(c => c !== conn);
                removePlayer(conn.peer);
            });
        }

        function handleNetworkData(peerId, data) {
            switch (data.type) {
                case 'init':
                    // New player joined, create their avatar
                    if (!gameState.players.has(data.player.id)) {
                        const player = new Player(data.player.id, false, data.player.color, data.player.characterType || 'Knight');
                        player.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, player);
                        scene.add(player.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'update':
                    // Update player position
                    const player = gameState.players.get(data.player.id);
                    if (player) {
                        player.updateFromNetwork(data.player);
                    } else {
                        // Player not found, request init
                        const newPlayer = new Player(data.player.id, false, data.player.color, data.player.characterType || 'Knight');
                        newPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, newPlayer);
                        scene.add(newPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerJoin':
                    if (!gameState.players.has(data.player.id)) {
                        const joinedPlayer = new Player(data.player.id, false, data.player.color, data.player.characterType || 'Knight');
                        joinedPlayer.updateFromNetwork(data.player);
                        gameState.players.set(data.player.id, joinedPlayer);
                        scene.add(joinedPlayer.mesh);
                        updatePlayerList();
                    }
                    break;

                case 'playerLeave':
                    removePlayer(data.id);
                    break;

                case 'damage':
                    const damagedPlayer = gameState.players.get(data.targetId);
                    if (damagedPlayer && !damagedPlayer.isLocal) {
                        damagedPlayer.health = data.health;
                        damagedPlayer.updateHealthBar();
                    }
                    break;

                case 'death':
                    const deadPlayer = gameState.players.get(data.playerId);
                    if (deadPlayer && !deadPlayer.isLocal) {
                        deadPlayer.isDead = true;
                        deadPlayer.deaths++;
                        deadPlayer.mesh.visible = false;
                        createDeathParticles(deadPlayer.position.clone());

                        // Give kill credit
                        if (data.killerId) {
                            const killer = gameState.players.get(data.killerId);
                            if (killer) killer.kills++;
                        }
                    }
                    break;

                case 'respawn':
                    const respawnedPlayer = gameState.players.get(data.playerId);
                    if (respawnedPlayer && !respawnedPlayer.isLocal) {
                        respawnedPlayer.health = respawnedPlayer.maxHealth;
                        respawnedPlayer.isDead = false;
                        respawnedPlayer.position.set(data.x, data.y, data.z);
                        respawnedPlayer.mesh.visible = true;
                        respawnedPlayer.updateHealthBar();
                    }
                    break;
            }
        }

        function removePlayer(id) {
            const player = gameState.players.get(id);
            if (player) {
                scene.remove(player.mesh);
                gameState.players.delete(id);
                updatePlayerList();
            }
        }

        function broadcast(data) {
            gameState.connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function connectToPeer() {
            const peerId = document.getElementById('connect-id').value.trim();
            if (!peerId) {
                updateStatus('Please enter a peer ID', 'error');
                return;
            }

            updateStatus('Connecting...', 'connecting');

            const conn = gameState.peer.connect(peerId, { reliable: true });
            handleConnection(conn);

            conn.on('open', () => {
                updateStatus('Connected!', 'connected');
                startGame();
            });

            conn.on('error', (err) => {
                updateStatus('Failed to connect: ' + err, 'error');
            });
        }

        function startSoloGame() {
            gameState.isHost = true;
            startGame();
        }

        function startGame() {
            gameState.gameStarted = true;

            // Create local player with selected character
            gameState.localPlayer = new Player(gameState.peer.id, true, null, gameState.selectedCharacter);
            gameState.players.set(gameState.peer.id, gameState.localPlayer);
            scene.add(gameState.localPlayer.mesh);

            // Hide connection panel, show HUD
            document.getElementById('connection-panel').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('controls-help').classList.remove('hidden');
            document.getElementById('minimap').classList.remove('hidden');
            document.getElementById('disconnect-btn').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('hidden');
            document.getElementById('weapon-indicator').classList.remove('hidden');
            document.getElementById('health-bar-container').classList.remove('hidden');
            document.getElementById('dash-indicator').classList.remove('hidden');

            // Initialize health bar
            updateLocalHealthBar(gameState.localPlayer.health, gameState.localPlayer.maxHealth);

            updatePlayerList();

            // Start game loop
            animate();
        }

        function disconnect() {
            // Notify all peers
            broadcast({ type: 'playerLeave', id: gameState.peer.id });

            // Close all connections
            gameState.connections.forEach(conn => conn.close());
            gameState.connections = [];

            // Reset game state
            gameState.gameStarted = false;
            gameState.players.forEach((player, id) => {
                scene.remove(player.mesh);
            });
            gameState.players.clear();
            gameState.localPlayer = null;

            // Show connection panel
            document.getElementById('connection-panel').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('controls-help').classList.add('hidden');
            document.getElementById('minimap').classList.add('hidden');
            document.getElementById('disconnect-btn').classList.add('hidden');
            document.getElementById('crosshair').classList.add('hidden');
            document.getElementById('weapon-indicator').classList.add('hidden');
            document.getElementById('health-bar-container').classList.add('hidden');
            document.getElementById('dash-indicator').classList.add('hidden');
            document.getElementById('death-screen').classList.remove('visible');
            document.getElementById('scoreboard').classList.remove('visible');

            // Exit pointer lock
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        function updatePlayerList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';

            gameState.players.forEach((player, id) => {
                const li = document.createElement('li');
                li.textContent = id.substring(0, 8) + (player.isLocal ? ' (You)' : '');
                if (player.isLocal) li.classList.add('you');
                list.appendChild(li);
            });
        }

        function copyPeerId() {
            const peerId = document.getElementById('peer-id').textContent;
            navigator.clipboard.writeText(peerId).then(() => {
                alert('Peer ID copied to clipboard!');
            });
        }

        // Minimap
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const size = 150;
            const scale = size / 100;

            ctx.clearRect(0, 0, size, size);

            // Draw background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.8)';
            ctx.fillRect(0, 0, size, size);

            // Draw obstacles (trees show as green circles)
            ctx.fillStyle = 'rgba(34, 139, 34, 0.8)';
            obstacles.forEach(obs => {
                const x = (obs.position.x + 50) * scale;
                const z = (obs.position.z + 50) * scale;
                // Trees are groups, so draw them as circles
                ctx.beginPath();
                ctx.arc(x, z, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw players
            gameState.players.forEach((player, id) => {
                const x = (player.position.x + 50) * scale;
                const z = (player.position.z + 50) * scale;

                ctx.beginPath();
                ctx.arc(x, z, 4, 0, Math.PI * 2);
                ctx.fillStyle = player.isLocal ? '#4caf50' : '#' + player.color.toString(16).padStart(6, '0');
                ctx.fill();

                // Direction indicator for local player
                if (player.isLocal) {
                    const dirX = Math.sin(player.rotation.y) * 8;
                    const dirZ = Math.cos(player.rotation.y) * 8;
                    ctx.beginPath();
                    ctx.moveTo(x, z);
                    ctx.lineTo(x + dirX, z + dirZ);
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        // Camera system
        function updateCamera() {
            if (!gameState.localPlayer) return;

            const player = gameState.localPlayer;
            const cameraDistance = 8;
            const cameraHeight = 3;

            // Calculate camera position based on yaw and pitch
            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraYaw) * Math.cos(cameraPitch) * cameraDistance,
                Math.sin(cameraPitch) * cameraDistance + cameraHeight,
                Math.cos(cameraYaw) * Math.cos(cameraPitch) * cameraDistance
            );

            camera.position.copy(player.position).add(cameraOffset);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        // Main game loop
        let lastNetworkUpdate = 0;
        const networkUpdateRate = 1000 / 20; // 20 updates per second

        function animate() {
            if (!gameState.gameStarted) return;

            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update local player
            if (gameState.localPlayer) {
                gameState.localPlayer.update(delta, keys, cameraYaw);

                // Update weapon indicator
                const weaponName = gameState.localPlayer.currentWeapon === 'gun' ? 'Gun' : 'Sword';
                document.getElementById('current-weapon-name').textContent = weaponName;

                // Update dash indicator
                updateDashIndicator();

                // Create dash trail while dashing
                if (gameState.localPlayer.isDashing) {
                    createDashTrail(gameState.localPlayer.position.clone(), gameState.localPlayer.color);
                }
            }

            // Update all player animations
            gameState.players.forEach(player => {
                player.updateAnimation(delta);
            });

            // Update camera
            updateCamera();

            // Network updates
            if (time * 1000 - lastNetworkUpdate > networkUpdateRate) {
                if (gameState.localPlayer && gameState.connections.length > 0) {
                    broadcast({
                        type: 'update',
                        player: gameState.localPlayer.getNetworkData()
                    });
                }
                lastNetworkUpdate = time * 1000;
            }

            // Update minimap
            updateMinimap();

            // Render
            renderer.render(scene, camera);
        }

        // Visual Effects & UI Functions
        function updateLocalHealthBar(health, maxHealth) {
            const fill = document.getElementById('health-bar-fill');
            const text = document.getElementById('health-text');
            const percent = (health / maxHealth) * 100;

            fill.style.width = percent + '%';

            if (percent > 50) {
                fill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
            } else if (percent > 25) {
                fill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
            } else {
                fill.style.background = 'linear-gradient(90deg, #f44336, #ff5722)';
            }

            text.textContent = Math.ceil(health) + ' / ' + maxHealth;
        }

        function showDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 150);
        }

        function shakeScreen() {
            const container = document.getElementById('game-container');
            container.style.transform = 'translate(' + (Math.random() * 10 - 5) + 'px, ' + (Math.random() * 10 - 5) + 'px)';
            setTimeout(() => {
                container.style.transform = 'translate(' + (Math.random() * 6 - 3) + 'px, ' + (Math.random() * 6 - 3) + 'px)';
            }, 50);
            setTimeout(() => {
                container.style.transform = '';
            }, 100);
        }

        function showHitMarker() {
            const marker = document.getElementById('hit-marker');
            marker.style.opacity = '1';
            marker.style.transform = 'translate(-50%, -50%) scale(1.2)';
            setTimeout(() => {
                marker.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 50);
            setTimeout(() => {
                marker.style.opacity = '0';
            }, 150);
        }

        function createDamageNumber(position, damage) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('-' + damage, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.5, 0.75, 1);
            sprite.position.copy(position);
            sprite.position.y += 2;
            scene.add(sprite);

            // Animate floating up and fading
            let life = 0;
            const animate = () => {
                life += 0.02;
                sprite.position.y += 0.03;
                sprite.material.opacity = 1 - life;

                if (life < 1) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(sprite);
                }
            };
            animate();
        }

        function createDeathParticles(position) {
            const particleCount = 30;
            const particles = [];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff4444 : 0xff8800,
                    transparent: true
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 10
                );
                scene.add(particle);
                particles.push(particle);
            }

            let life = 0;
            const animate = () => {
                life += 0.02;

                particles.forEach(p => {
                    p.position.add(p.velocity.clone().multiplyScalar(0.016));
                    p.velocity.y -= 15 * 0.016;
                    p.material.opacity = 1 - life;
                    p.scale.setScalar(1 - life * 0.5);
                });

                if (life < 1) {
                    requestAnimationFrame(animate);
                } else {
                    particles.forEach(p => scene.remove(p));
                }
            };
            animate();
        }

        function createDashTrail(position, color) {
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const trail = new THREE.Mesh(geometry, material);
            trail.position.copy(position);
            scene.add(trail);

            let life = 0;
            const animate = () => {
                life += 0.1;
                trail.material.opacity = 0.6 * (1 - life);
                trail.scale.setScalar(1 + life);

                if (life < 1) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(trail);
                }
            };
            animate();
        }

        function showDeathScreen(killerId) {
            const screen = document.getElementById('death-screen');
            const killerName = document.getElementById('killer-name');
            const timer = document.getElementById('respawn-timer');

            const killer = gameState.players.get(killerId);
            killerName.textContent = killer ? killerId.substring(0, 8) : 'the arena';

            screen.classList.add('visible');

            let countdown = 3;
            timer.textContent = 'Respawning in ' + countdown + '...';

            const interval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    timer.textContent = 'Respawning in ' + countdown + '...';
                } else {
                    timer.textContent = 'Respawning...';
                    clearInterval(interval);
                }
            }, 1000);
        }

        function hideDeathScreen() {
            document.getElementById('death-screen').classList.remove('visible');
        }

        function updateScoreboard() {
            const tbody = document.getElementById('scoreboard-body');
            tbody.innerHTML = '';

            // Sort players by kills
            const sortedPlayers = Array.from(gameState.players.values())
                .sort((a, b) => b.kills - a.kills);

            sortedPlayers.forEach(player => {
                const tr = document.createElement('tr');
                if (player.isLocal) tr.classList.add('you');

                tr.innerHTML = `
                    <td>${player.id.substring(0, 8)}${player.isLocal ? ' (You)' : ''}</td>
                    <td class="kills">${player.kills}</td>
                    <td class="deaths">${player.deaths}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function updateDashIndicator() {
            if (!gameState.localPlayer) return;

            const fill = document.getElementById('dash-cooldown-fill');
            const cooldownPercent = 1 - (gameState.localPlayer.dashCooldown / gameState.localPlayer.maxDashCooldown);
            fill.style.width = Math.min(100, cooldownPercent * 100) + '%';
        }

        // Update System
        function compareVersions(v1, v2) {
            const parts1 = v1.split('.').map(Number);
            const parts2 = v2.split('.').map(Number);

            for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
                const p1 = parts1[i] || 0;
                const p2 = parts2[i] || 0;
                if (p1 < p2) return -1;
                if (p1 > p2) return 1;
            }
            return 0;
        }

        async function checkForUpdates() {
            const btn = document.getElementById('update-btn');
            const status = document.getElementById('update-status');

            btn.disabled = true;
            btn.textContent = 'Checking...';
            status.textContent = '';
            status.className = '';

            try {
                const response = await fetch(VERSION_URL + '?t=' + Date.now()); // Cache bust
                if (!response.ok) throw new Error('Could not fetch version info');

                const data = await response.json();
                const latestVersion = data.version;
                const comparison = compareVersions(GAME_VERSION, latestVersion);

                if (comparison < 0) {
                    // Update available
                    btn.textContent = `Update to v${latestVersion}`;
                    btn.classList.add('has-update');
                    btn.disabled = false;
                    btn.onclick = () => {
                        btn.textContent = 'Redirecting...';
                        btn.disabled = true;
                        setTimeout(() => {
                            window.location.href = GAME_URL;
                        }, 500);
                    };
                    status.textContent = `New version available! (${data.changelog || 'Bug fixes and improvements'})`;
                    status.className = 'update-available';
                } else {
                    // Up to date
                    btn.textContent = 'Check for Updates';
                    btn.classList.remove('has-update');
                    btn.disabled = false;
                    btn.onclick = checkForUpdates;
                    status.textContent = 'You have the latest version!';
                    status.className = 'up-to-date';
                }
            } catch (error) {
                console.error('Update check failed:', error);
                btn.textContent = 'Check for Updates';
                btn.disabled = false;
                btn.onclick = checkForUpdates;
                status.textContent = 'Could not check for updates (offline or repo not set up)';
                status.className = '';
            }
        }

        // Initialize everything
        async function init() {
            // Display current version
            document.getElementById('current-version').textContent = GAME_VERSION;

            // Load 3D assets first
            await loadAssets();

            initScene();
            initInput();
            initPeer();

            // Auto-check for updates on load (optional)
            setTimeout(checkForUpdates, 2000);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
